type Model = {
  id: string;
  name: string;
  code: string;
};

export const cubeCode = `// Cube
const { sketchRectangle, EdgeFinder } = replicad;

export const defaultParams = {
  length: 100,
  filletRadius: 5,
};

export const main = (r, { length, filletRadius }) => {
  let shape = sketchRectangle(length, length)
    .extrude(length)
    .fillet({
      radius: filletRadius,
      filter: new EdgeFinder(),
    })

  return shape;
};
`;

export const birdhouseCode = `// Birdhouse
// source: https://github.com/Irev-Dev/curated-code-cad

const defaultParams = {
  height: 85.0,
  width: 120.0,
  thickness: 2.0,
  holeDiameter: 50.0,
  hookHeight: 10.0,
  filletEdges: true,
};

const { drawCircle, draw, makePlane } = replicad;

function main(
  r,
  { width: inputWidth, height, thickness, holeDiameter, hookHeight, filletEdges }
) {
  const length = inputWidth;
  const width = inputWidth * 0.9;

  let tobleroneShape = draw([-width / 2, 0])
    .lineTo([0, height])
    .lineTo([width / 2, 0])
    .close()
    .sketchOnPlane("XZ", -length / 2)
    .extrude(length)
    .shell(thickness, (f) => f.parallelTo("XZ"));

  if (filletEdges) {
    tobleroneShape = tobleroneShape.fillet(thickness / 2, (e) =>
      e
        .inDirection("Y")
        .either([(f) => f.inPlane("XY"), (f) => f.inPlane("XY", height)])
    );
  }

  const hole = drawCircle(holeDiameter / 2)
    .sketchOnPlane(makePlane("YZ").translate([-length / 2, 0, height / 3]))
    .extrude(length);

  const base = tobleroneShape.cut(hole);
  const body = base.clone().fuse(base.rotate(90));

  const hookWidth = length / 2;
  const hook = draw([0, hookHeight / 2])
    .smoothSplineTo([hookHeight / 2, 0], -45)
    .lineTo([hookWidth / 2, 0])
    .line(-hookWidth / 4, hookHeight / 2)
    .smoothSplineTo([0, hookHeight], {
      endTangent: 180,
      endFactor: 0.6,
    })
    .closeWithMirror()
    .sketchOnPlane("XZ")
    .extrude(thickness)
    .translate([0, thickness / 2, height - thickness / 2]);

  return body.fuse(hook);
}
`;

export const trayCode = `const { makeSolid, makeFace, assembleWire, EdgeFinder, genericSweep, Plane } =
  replicad;

const defaultParams = {
  baseWidth: 30,
  baseDepth: 20,
  cornerRadius: 5,
  profileLine1X: 5,
  profileLine1Y: 5,
  profileLine2X: 2,
  profileLine2Y: 3,
  brimWidth: 2,
  brimHeight: 1,
  profileBulgeArcX: 0,
  profileBulgeArcY: 1,
  profileBulgeFactor: 0.2,
};

function profileBox(inputProfile, base) {
  const start = inputProfile.blueprint.firstPoint;
  const profile = inputProfile.translate(-start[0], -start[1]);

  const end = profile.blueprint.lastPoint;

  const baseSketch = base.sketchOnPlane();

  // We create the side of the box
  const side = baseSketch.clone().sweepSketch(
    (plane) => {
      return profile.sketchOnPlane(plane);
    },
    {
      withContact: true,
    }
  );

  // We put all the pieces together
  return makeSolid([
    side,
    // The face generated by sweeping the end of the profile
    makeFace(assembleWire(new EdgeFinder().inPlane("XY", end[1]).find(side))),
    // The face generated by the base
    baseSketch.face(),
  ]);
}

const { draw, drawRoundedRectangle } = replicad;

function main(
  r,
  {
    baseWidth,
    baseDepth,
    cornerRadius,
    profileLine1X,
    profileLine1Y,
    profileLine2X,
    profileLine2Y,
    brimWidth,
    brimHeight,
    profileBulgeArcX,
    profileBulgeArcY,
    profileBulgeFactor,
  } = defaultParams
) {
  const base = drawRoundedRectangle(baseWidth, baseDepth, cornerRadius);

  const profile = draw()
    .line(profileLine1X, profileLine1Y)
    .line(profileLine2X, profileLine2Y)
    .hLine(-brimWidth)
    .vLine(-brimHeight)
    .bulgeArcTo([profileBulgeArcX, profileBulgeArcY], profileBulgeFactor)
    .done();

  return profileBox(profile, base);
}`;

export const vaseCode = `const { draw } = replicad;

const defaultParams = {
  height: 100,
  baseWidth: 20,
  wallThickness: 5,
  lowerCircleRadius: 1.5,
  lowerCirclePosition: 0.25,
  higherCircleRadius: 0.75,
  higherCirclePosition: 0.75,
  topRadius: 0.9,
  topFillet: true,
  bottomHeavy: true,
};

const main = (
  r,
  {
    height,
    baseWidth,
    wallThickness,
    lowerCirclePosition,
    lowerCircleRadius,
    higherCircleRadius,
    higherCirclePosition,
    topRadius,
    topFillet,
    bottomHeavy,
  }
) => {
  const splinesConfig = [
    { position: lowerCirclePosition, radius: lowerCircleRadius },
    {
      position: higherCirclePosition,
      radius: higherCircleRadius,
      startFactor: bottomHeavy ? 3 : 1,
    },
    { position: 1, radius: topRadius, startFactor: bottomHeavy ? 3 : 1 },
  ];

  const sketchVaseProfile = draw().hLine(baseWidth);

  splinesConfig.forEach(({ position, radius, startFactor, endFactor }) => {
    sketchVaseProfile.smoothSplineTo([baseWidth * radius, height * position], {
      endTangent: [0, 1],
      startFactor,
      endFactor,
    });
  });

  let vase = sketchVaseProfile
    .lineTo([0, height])
    .close()
    .sketchOnPlane("XZ")
    .revolve();

  if (wallThickness) {
    vase = vase.shell(wallThickness, (f) => f.containsPoint([0, 0, height]));
  }

  if (topFillet) {
    vase = vase.fillet(wallThickness / 3, (e) => e.inPlane("XY", height));
  }

  return vase;
};
`;

export const wavyVase = `const { drawCircle, drawPolysides, polysideInnerRadius } = replicad;

const defaultParams = {
  height: 150,
  radius: 40,
  sidesCount: 12,
  sideRadius: -2,
  sideTwist: 6,
  endFactor: 1.5,
  topFillet: 0,
  bottomFillet: 5,

  holeMode: 1,
  wallThickness: 2,
};

const main = (
  r,
  {
    height,
    radius,
    sidesCount,
    sideRadius,
    sideTwist,
    endFactor,
    topFillet,
    bottomFillet,
    holeMode,
    wallThickness,
  }
) => {
  const extrusionProfile = endFactor
    ? { profile: "s-curve", endFactor }
    : undefined;
  const twistAngle = (360 / sidesCount) * sideTwist;

  let shape = drawPolysides(radius, sidesCount, -sideRadius)
    .sketchOnPlane()
    .extrude(height, {
      twistAngle,
      extrusionProfile,
    });

  if (bottomFillet) {
    shape = shape.fillet(bottomFillet, (e) => e.inPlane("XY"));
  }

  if (holeMode === 1 || holeMode === 2) {
    const holeHeight = height - wallThickness;

    let hole;
    if (holeMode === 1) {
      const insideRadius =
        polysideInnerRadius(radius, sidesCount, sideRadius) - wallThickness;

      hole = drawCircle(insideRadius).sketchOnPlane().extrude(holeHeight, {
        extrusionProfile,
      });

      shape = shape.cut(
        hole
          .fillet(
            Math.max(wallThickness / 3, bottomFillet - wallThickness),
            (e) => e.inPlane("XY")
          )
          .translate([0, 0, wallThickness])
      );
    } else if (holeMode === 2) {
      shape = shape.shell(wallThickness, (f) => f.inPlane("XY", height));
    }
  }

  if (topFillet) {
    shape = shape.fillet(topFillet, (e) => e.inPlane("XY", height));
  }
  return shape;
};
`;

export const cycloidalGear = `const { drawCircle, drawParametricFunction } = replicad;

const defaultParams = {
  height: 40,
  r1: 12,
  r2: 1,
  circleDiameter: 2,
  twistAngle: 90,
};

const hypocycloid = (t, r1, r2) => {
  return [
    (r1 - r2) * Math.cos(t) + r2 * Math.cos((r1 / r2) * t - t),
    (r1 - r2) * Math.sin(t) + r2 * Math.sin(-((r1 / r2) * t - t)),
  ];
};

const epicycloid = (t, r1, r2) => {
  return [
    (r1 + r2) * Math.cos(t) - r2 * Math.cos((r1 / r2) * t + t),
    (r1 + r2) * Math.sin(t) - r2 * Math.sin((r1 / r2) * t + t),
  ];
};

const gear = (t, r1 = defaultParams.r1, r2 = defaultParams.r2) => {
  if ((-1) ** (1 + Math.floor((t / 2 / Math.PI) * (r1 / r2))) < 0)
    return epicycloid(t, r1, r2);
  else return hypocycloid(t, r1, r2);
};

const main = (r, { height, r1, r2, twistAngle, circleDiameter }) => {
  const base = drawParametricFunction((t) => gear(2 * Math.PI * t, r1, r2))
    .sketchOnPlane()
    .extrude(height, { twistAngle: twistAngle });

  const hole = drawCircle(circleDiameter).sketchOnPlane().extrude(height);

  return base.cut(hole);
};
`;

export const bottle = `const defaultParams = {
  width: 50,
  height: 70,
  thickness: 30,
};

const { draw, makeCylinder, makeOffset, FaceFinder } = replicad;

const main = (
  r,
  { width: myWidth, height: myHeight, thickness: myThickness }
) => {
  let shape = draw([-myWidth / 2, 0])
    .vLine(-myThickness / 4)
    .threePointsArc(myWidth, 0, myWidth / 2, -myThickness / 4)
    .vLine(myThickness / 4)
    .closeWithMirror()
    .sketchOnPlane()
    .extrude(myHeight)
    .fillet(myThickness / 12);

  const myNeckRadius = myThickness / 4;
  const myNeckHeight = myHeight / 10;
  const neck = makeCylinder(
    myNeckRadius,
    myNeckHeight,
    [0, 0, myHeight],
    [0, 0, 1]
  );

  shape = shape.fuse(neck);

  shape = shape.shell(myThickness / 50, (f) =>
    f.inPlane("XY", [0, 0, myHeight + myNeckHeight])
  );

  const neckFace = new FaceFinder()
    .containsPoint([0, myNeckRadius, myHeight])
    .ofSurfaceType("CYLINDRE")
    .find(shape.clone(), { unique: true });

  const bottomThreadFace = makeOffset(neckFace, -0.01 * myNeckRadius).faces[0];
  const baseThreadSketch = draw([0.75, 0.25])
    .halfEllipse(2, 0.5, 0.1)
    .close()
    .sketchOnFace(bottomThreadFace, "bounds");

  const topThreadFace = makeOffset(neckFace, 0.05 * myNeckRadius).faces[0];
  const topThreadSketch = draw([0.75, 0.25])
    .halfEllipse(2, 0.5, 0.05)
    .close()
    .sketchOnFace(topThreadFace, "bounds");

  const thread = baseThreadSketch.loftWith(topThreadSketch);

  return shape.fuse(thread);
};
`;

export const gridfinityBox = `const {
  draw,
  drawRoundedRectangle,
  drawCircle,
  makeSolid,
  assembleWire,
  makeFace,
  EdgeFinder,
} = replicad;

const defaultParams = {
  xSize: 2,
  ySize: 1,
  height: 0.5,
  withMagnet: false,
  withScrew: false,
  magnetRadius: 3.25,
  magnetHeight: 2,
  screwRadius: 1.5,
  keepFull: false,
  wallThickness: 1.2,
};

// Gridfinity magic numbers
const SIZE = 42.0;
const CLEARANCE = 0.5;
const AXIS_CLEARANCE = (CLEARANCE * Math.sqrt(2)) / 4;

const CORNER_RADIUS = 4;
const TOP_FILLET = 0.6;

const SOCKET_HEIGHT = 5;
const SOCKET_SMALL_TAPER = 0.8;
const SOCKET_BIG_TAPER = 2.4;
const SOCKET_VERTICAL_PART =
  SOCKET_HEIGHT - SOCKET_SMALL_TAPER - SOCKET_BIG_TAPER;
const SOCKET_TAPER_WIDTH = SOCKET_SMALL_TAPER + SOCKET_BIG_TAPER;

const socketProfile = (_, startPoint) => {
  const full = draw([-CLEARANCE / 2, 0])
    .vLine(-CLEARANCE / 2)
    .lineTo([-SOCKET_BIG_TAPER, -SOCKET_BIG_TAPER])
    .vLine(-SOCKET_VERTICAL_PART)
    .line(-SOCKET_SMALL_TAPER, -SOCKET_SMALL_TAPER)
    .done()
    .translate(CLEARANCE / 2, 0);

  return full.sketchOnPlane("XZ", startPoint);
};

const buildSocket = ({
  magnetRadius = 3.25,
  magnetHeight = 2,
  screwRadius = 1.5,
  withScrew = true,
  withMagnet = true,
} = {}) => {
  const baseSocket = drawRoundedRectangle(
    SIZE - CLEARANCE,
    SIZE - CLEARANCE,
    CORNER_RADIUS
  ).sketchOnPlane();

  const slotSide = baseSocket.sweepSketch(socketProfile, {
    withContact: true,
  });

  let slot = makeSolid([
    slotSide,
    makeFace(
      assembleWire(
        new EdgeFinder().inPlane("XY", -SOCKET_HEIGHT).find(slotSide)
      )
    ),
    makeFace(assembleWire(new EdgeFinder().inPlane("XY", 0).find(slotSide))),
  ]);

  if (withScrew || withMagnet) {
    const magnetCutout = withMagnet
      ? drawCircle(magnetRadius).sketchOnPlane().extrude(magnetHeight)
      : null;
    const screwCutout = withScrew
      ? drawCircle(screwRadius).sketchOnPlane().extrude(SOCKET_HEIGHT)
      : null;

    const cutout =
      magnetCutout && screwCutout
        ? magnetCutout.fuse(screwCutout)
        : magnetCutout || screwCutout;

    slot = slot
      .cut(cutout.clone().translate([-13, -13, -5]))
      .cut(cutout.clone().translate([-13, 13, -5]))
      .cut(cutout.clone().translate([13, 13, -5]))
      .cut(cutout.clone().translate([13, -13, -5]));
  }

  return slot;
};

const range = (i) => [...Array(i).keys()];
const cloneOnGrid = (
  shape,
  { xSteps = 1, ySteps = 1, span = 10, xSpan = null, ySpan = null }
) => {
  const xCorr = ((xSteps - 1) * (xSpan || span)) / 2;
  const yCorr = ((ySteps - 1) * (ySpan || xSpan || span)) / 2;

  const translations = range(xSteps).flatMap((i) => {
    return range(ySteps).map((j) => [i * SIZE - xCorr, j * SIZE - yCorr, 0]);
  });
  return translations.map((translation) =>
    shape.clone().translate(translation)
  );
};

const buildTopShape = ({
  xSize,
  ySize,
  includeLip = true,
  wallThickness = 1.2,
}) => {
  const topShape = (basePlane, startPosition) => {
    const sketcher = draw([-SOCKET_TAPER_WIDTH, 0])
      .line(SOCKET_SMALL_TAPER, SOCKET_SMALL_TAPER)
      .vLine(SOCKET_VERTICAL_PART)
      .line(SOCKET_BIG_TAPER, SOCKET_BIG_TAPER);

    if (includeLip) {
      sketcher
        .vLineTo(-(SOCKET_TAPER_WIDTH + wallThickness))
        .lineTo([-SOCKET_TAPER_WIDTH, -wallThickness]);
    } else {
      sketcher.vLineTo(0);
    }

    const basicShape = sketcher.close();

    const shiftedShape = basicShape
      .translate(AXIS_CLEARANCE, -AXIS_CLEARANCE)
      .intersect(
        drawRoundedRectangle(10, 10).translate(-5, includeLip ? 0 : 5)
      );

    // We need to shave off the clearance
    let topProfile = shiftedShape
      .translate(CLEARANCE / 2, 0)
      .intersect(drawRoundedRectangle(10, 10).translate(-5, 0));

    if (includeLip) {
      // We remove the wall if we add a lip
      topProfile = topProfile.cut(
        drawRoundedRectangle(1.2, 10).translate(-0.6, -5)
      );
    }

    return topProfile.sketchOnPlane("XZ", startPosition);
  };

  const boxSketch = drawRoundedRectangle(
    xSize * SIZE - CLEARANCE,
    ySize * SIZE - CLEARANCE,
    CORNER_RADIUS
  ).sketchOnPlane();

  return boxSketch
    .sweepSketch(topShape, { withContact: true })
    .fillet(TOP_FILLET, (e) =>
      e.inBox(
        [-xSize * SIZE, -ySize * SIZE, SOCKET_HEIGHT],
        [xSize * SIZE, ySize * SIZE, SOCKET_HEIGHT - 1]
      )
    );
};

function main(
  r,
  {
    xSize = 2,
    ySize = 1,
    height = 0.5,
    keepFull = false,
    wallThickness = 1.2,
    withMagnet = false,
    withScrew = false,
    magnetRadius = 3.25,
    magnetHeight = 2,
    screwRadius = 1.5,
  } = {}
) {
  const stdHeight = height * SIZE;

  let box = drawRoundedRectangle(
    xSize * SIZE - CLEARANCE,
    ySize * SIZE - CLEARANCE,
    CORNER_RADIUS
  )
    .sketchOnPlane()
    .extrude(stdHeight);

  if (!keepFull) {
    box = box.shell(wallThickness, (f) => f.inPlane("XY", stdHeight));
  }

  const top = buildTopShape({
    xSize,
    ySize,
    includeLip: !keepFull,
  }).translateZ(stdHeight);

  const socket = buildSocket({
    withMagnet,
    withScrew,
    magnetRadius,
    magnetHeight,
    screwRadius,
  });

  let base = null;
  cloneOnGrid(socket, { xSteps: xSize, ySteps: ySize, span: SIZE }).forEach(
    (movedSocket) => {
      if (base) base = base.fuse(movedSocket, { optimisation: "commonFace" });
      else base = movedSocket;
    }
  );
  return base
    .fuse(box, { optimisation: "commonFace" })
    .fuse(top, { optimisation: "commonFace" });
};
`;

export const decoratedBox = `const { sketchRectangle, EdgeFinder, FaceFinder } = replicad;
import { addVoronoi, addGrid, addHoneycomb } from "https://cdn.jsdelivr.net/npm/replicad-decorate/dist/studio/replicad-decorate.js";

export const defaultParams = {
  height: 30,
  depth: 80,
  width: 120,
  filletRadius: 5,
  shellThickness: 2,
  decorationStyle: "voronoi",
  decorationMargin: 2,
  decorationPadding: 2,
  decorationRadius: 5,
  decorationCellCount: 20,
  decorationSeed: 5,
};

export const main = (r, { height, depth, width, filletRadius, shellThickness, decorationStyle, decorationMargin, decorationPadding, decorationRadius, decorationCellCount, decorationSeed }) => {
  let shape = sketchRectangle(depth, width)
    .extrude(height)
    .fillet({
      radius: filletRadius,
      filter: new EdgeFinder().inDirection("Z"),
    })
    .shell({
      thickness: shellThickness,
      filter: new FaceFinder().inPlane("XY", height),
    });

  const face = new FaceFinder().inPlane("XY", height)[0];

  const decorateParams = { faceIndex: 18, depth: -shellThickness, radius: decorationRadius, margin: decorationMargin, padding: decorationPadding, cellCount: decorationCellCount, seed: decorationSeed }

  if (decorationStyle === "voronoi") {
    shape = addVoronoi(shape, decorateParams);
  } else if (decorationStyle === "grid") {
    shape = addGrid(shape, decorateParams);
  } else if (decorationStyle === "honeycomb") {
    shape = addHoneycomb(shape, decorateParams);
  } else {
    shape = addHoneycomb(shape, decorateParams);
  }

  return shape;
};
`;

const cardHolderCode = `//home/lee/Code/lee/ScreenDoorHandle/main.rcad:1.1,58.1
// All measurements are in millimeters.

/** @typedef { typeof import("replicad") } replicadLib */
/** @type {function(replicadLib, typeof defaultParams): any} */

const defaultParams = {
};

const main = ({ Sketcher, sketchRectangle, sketchCircle, Plane, makeSphere,FaceFinder }, {}) => {
  const handleBase = new Sketcher("XY")
    .vLine(89.0)
    .hLine(20.5)
    .line( 57.0 - 20.5, -3.5)
    .vLine(-82.0)
    .line(-57.0 + 20.5, -3.5)
    .hLine(-20.5)
    .close()
    .extrude(9.0)
    .fillet(5.0, e => e.inDirection('Z').containsPoint([57, 3.5, 0]))
    .fillet(5.0, e => e.inDirection('Z').containsPoint([57, 89.0 - 3.5, 0]))
    .fillet(1.0, e => e.inBox([0,0,9], [20.5, 89.0, 0]))
   
  const border = 3.0;

  const fingerAreaNegative = new Sketcher("XY")
    .line( 57.0 - 20.5 - border, -3.5)
    .vLine(-82.0 + (border * 2))
    .line(-57.0 + 20.5 + border, -3.5)
    .close()
    .extrude(30.0)  // =RD= increased this to 30 mm as example
    .fillet(5.0, edgeFilter => edgeFilter.inDirection('Z'))
    .fillet(1.5);   // =RD= added a fillet here

  const lockNegative = sketchRectangle(25.0, 7.0)
    .extrude(20.0)
    .rotate(90, undefined, [1, 0, 0])
    .rotate(90, undefined, [0, 0, 1])
    .translate([0, 0, 3.5]);

  const lockSmallTabSpaceNegative = sketchRectangle(15.0, 5.0)
    .extrude(3.0)
    .rotate(90, undefined, [1, 0, 0])
    .rotate(90, undefined, [0, 0, 1])
    .translate([0, 0, 2.5]);

  const screwHole = sketchCircle(4.0, new Plane([0, 0, 0]))
    .loftWith([
      sketchCircle(1.5, new Plane([0, 0, -3.0])),
      sketchCircle(1.5, new Plane([0, 0, -9.0]))
    ])
    .translate([0.0, 0.0, 9.0]);

  const cutFingerArea = handleBase.cut(fingerAreaNegative.translate([20.5, 89 - border, 2.0]));
  const filletFingerArea = cutFingerArea.fillet(1.4) // Here
  // const filletFingerArea = cutFingerArea // Here
  const cutLock = filletFingerArea.cut(lockNegative.translate([2.0, 89.0 / 2, 0]));
  const cutLockTab = cutLock.cut(lockSmallTabSpaceNegative.translate([57 - 3, 89.0 / 2, 0]));
  const cutScrewHoleTop = cutLockTab.cut(screwHole.clone().translate([10.0, 6.0, 0.0]));
  const cutScrewHoleBottom = cutScrewHoleTop.cut(screwHole.translate([10.0, 89.0 - 6.0, 0.0]));
  
  const handle = cutScrewHoleBottom
 //  let marker = makeSphere(1).translate([57.0 - 20, 89 / 2, 2.0]);
 //  const handle = cutScrewHoleBottom.fuse(marker);
  return {shape: handle,  highlight: new FaceFinder().inPlane("XY", 9)};
}
`;

export const staircaseCode = `// Parametric Staircase Model
const { draw, drawRoundedRectangle, drawCircle } = replicad;

const defaultParams = {
  // Main staircase dimensions
  totalHeight: 2700, // mm - typical floor-to-floor height
  totalRun: 3600,    // mm - horizontal length of staircase
  width: 1200,        // mm - width of stairs
  numSteps: 15,      // number of steps
  
  // Step customization
  stepThickness: 50, // mm - thickness of each step
  nosing: 25,        // mm - step overhang
  roundedSteps: true,
  cornerRadius: 10,  // mm - radius for rounded corners on steps
  
  // Stringer options
  includeStringers: true,
  stringerWidth: 50, // mm
  stringerThickness: 25, // mm
  
  // Handrail options
  includeHandrails: true,
  handrailHeight: 900, // mm - height from step to top of handrail
  handrailDiameter: 60, // mm
  balusters: true,
  balusterSpacing: 200, // mm
  balusterDiameter: 20, // mm
};

/**
 * Creates a parametric staircase model
 * @param r Replicad environment
 * @param params Staircase parameters
 * @returns The complete staircase model
 */
function main(r, params = {}) {
  // Merge default parameters with provided ones
  const p = { ...defaultParams, ...params };
  
  // Calculate derived dimensions
  const stepRise = p.totalHeight / p.numSteps; // Height of each step
  const stepRun = p.totalRun / p.numSteps;     // Depth of each step
  
  // Validation of dimensions against typical building codes
  // Most codes require:
  // - Rise: 150-220mm (5.9-8.7")
  // - Run: minimum 240mm (9.5")
  // - 2R + T = 550-700mm (where R=rise, T=tread)
  if (stepRise < 150 || stepRise > 220) {
    console.warn(\`Warning: Step rise (\${stepRise.toFixed(1)}mm) outside recommended range (150-220mm)\`);
  }
  if (stepRun < 240) {
    console.warn(\`Warning: Step run (\${stepRun.toFixed(1)}mm) below recommended minimum (240mm)\`);
  }
  const walkingFormula = 2 * stepRise + stepRun;
  if (walkingFormula < 550 || walkingFormula > 700) {
    console.warn(\`Warning: Walking formula (2R + T = \${walkingFormula.toFixed(1)}mm) outside recommended range (550-700mm)\`);
  }
  
  // Build individual steps
  let staircase = null;
  
  for (let i = 0; i < p.numSteps; i++) {
    // Calculate step position
    const x = i * stepRun;
    const z = i * stepRise;
    
    // Create basic step shape
    let step;
    if (p.roundedSteps) {
      // For rounded rectangle, we need width, height, and corner radius
      step = drawRoundedRectangle(stepRun + p.nosing, p.width, p.cornerRadius)
        .sketchOnPlane("XY") // Steps are in XY plane
        .extrude(p.stepThickness) // Extrude to create 3D step
        .translate([x - p.nosing, 0, z]); // Position step
    } else {
      // For regular rectangle using draw
      step = draw([x - p.nosing, -p.width / 2])
        .hLine(stepRun + p.nosing) // Horizontal line to the right
        .vLine(p.width)            // Vertical line up
        .hLine(-(stepRun + p.nosing)) // Horizontal line to the left
        .close()
        .sketchOnPlane("XY")
        .extrude(p.stepThickness)
        .translate([-p.nosing, 0, z]);
    }
    
    // Add step to staircase
    if (staircase === null) {
      staircase = step;
    } else {
      staircase = staircase.fuse(step);
    }
  }
  
  // Add stringers if requested
  if (p.includeStringers) {
    // Create left stringer shape
    // First create the profile in XZ plane
    const leftStringerProfile = [];
    
    // Add points for the stringer profile
    leftStringerProfile.push([-p.nosing, 0]); // Bottom front
    leftStringerProfile.push([p.totalRun, 0]); // Bottom back
    leftStringerProfile.push([p.totalRun, p.totalHeight]); // Top back
    leftStringerProfile.push([p.totalRun - stepRun, p.totalHeight]); // Top step
    
        // Add sawtooth pattern for steps
    for (let i = p.numSteps - 1; i >= 0; i--) {
      leftStringerProfile.push([i * stepRun, i * stepRise + p.stepThickness]);
      leftStringerProfile.push([i * stepRun, i * stepRise]);
    }
    
    // Create the stringer profile using these points
    let leftStringerPen = draw(leftStringerProfile[0]);
    for (let i = 1; i < leftStringerProfile.length; i++) {
      leftStringerPen = leftStringerPen.lineTo(leftStringerProfile[i]);
    }
    
    // Create left stringer
    const leftStringerSketch = leftStringerPen.close().sketchOnPlane("XZ");
    const leftStringer = leftStringerSketch.extrude(p.stringerWidth)
      .translate([0, -p.width / 2 + p.stringerWidth, 0]);
    
    // Create right stringer
    const rightStringer = leftStringer.clone()
      .translate([0, p.width - p.stringerWidth, 0]);
    
    // Add stringers to staircase
    staircase = staircase.fuse(leftStringer).fuse(rightStringer);
  }
  
  // Add handrails if requested
  if (p.includeHandrails) {
    // Create handrails on both sides
    
    // Helper function to create a single baluster
    const createBaluster = (x, y, z) => {
      return drawCircle(p.balusterDiameter / 2)
        .sketchOnPlane("XY")
        .extrude(p.handrailHeight)
        .translate([x, y, z]);
    };
    
    // Helper function to create a handrail segment
    const createHandrailSegment = (x1, y1, z1, x2, y2, z2) => {
      // Create a cylinder between two points
      // We'll approximate this with an extruded circle along the Z axis,
      // then rotate and position it correctly
      
      // Calculate segment length and angles
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dz = z2 - z1;
      const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
      
      // Create basic cylinder
      const segment = drawCircle(p.handrailDiameter / 2)
        .sketchOnPlane("XY")
        .extrude(length);
      
      // If the segment is perfectly vertical, no rotation needed
      if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) {
        return segment.translate([x1, y1, z1]);
      }
      
      // Otherwise we need to rotate to align with the segment direction
      const angleX = 90 - Math.atan2(dz, Math.sqrt(dx * dx + dy * dy)) * (180 / Math.PI);
      
      return segment
        .rotate(angleX, [0, 1, 0], [0, 1, 0]) // Rotate around Y axis for X-Z angle
        .translate([x1, y1, z1]); // Move to start position
    };
    
    // Create left and right handrails
    let leftHandrail = null;
    let rightHandrail = null;
    
    // Left and right Y positions
    const leftY = -p.width / 2 + p.stringerWidth / 2;
    const rightY = p.width / 2 - p.stringerWidth / 2;
    
    // Create segments for each step section
    for (let i = 0; i < p.numSteps; i++) {
      const x1 = i * stepRun;
      const z1 = i * stepRise;
      const x2 = (i + 1) * stepRun;
      const z2 = (i + 1) * stepRise;
      
      // Create handrail segments with proper height offset
      const leftSegment = createHandrailSegment(
        x1, leftY, z1 + p.handrailHeight,
        x2, leftY, z2 + p.handrailHeight
      );
      
      const rightSegment = createHandrailSegment(
        x1, rightY, z1 + p.handrailHeight,
        x2, rightY, z2 + p.handrailHeight
      );
      
      // Add segments to respective handrails
      if (leftHandrail === null) {
        leftHandrail = leftSegment;
      } else {
        leftHandrail = leftHandrail.fuse(leftSegment);
      }
      
      if (rightHandrail === null) {
        rightHandrail = rightSegment;
      } else {
        rightHandrail = rightHandrail.fuse(rightSegment);
      }
      
      // Add balusters if requested
      if (p.balusters) {
        // Place balusters at start of each step
        const leftBaluster = createBaluster(x1, leftY, z1);
        const rightBaluster = createBaluster(x1, rightY, z1);
        
        staircase = staircase.fuse(leftBaluster).fuse(rightBaluster);
        
        // Add intermediate balusters if step is wide enough
        if (stepRun > p.balusterSpacing * 1.5) {
          const numIntermediateBalusters = Math.floor(stepRun / p.balusterSpacing) - 1;
          
          for (let j = 1; j <= numIntermediateBalusters; j++) {
            const balusterX = x1 + (j * stepRun) / (numIntermediateBalusters + 1);
            const balusterZ = z1 + (j * stepRise) / (numIntermediateBalusters + 1);
            
            const intermediateLeftBaluster = createBaluster(balusterX, leftY, balusterZ);
            const intermediateRightBaluster = createBaluster(balusterX, rightY, balusterZ);
            
            staircase = staircase
              .fuse(intermediateLeftBaluster)
              .fuse(intermediateRightBaluster);
          }
        }
      }
    }
    
    // Add final balusters at the top
    if (p.balusters) {
      const topLeftBaluster = createBaluster(p.totalRun, leftY, p.totalHeight);
      const topRightBaluster = createBaluster(p.totalRun, rightY, p.totalHeight);
      staircase = staircase.fuse(topLeftBaluster).fuse(topRightBaluster);
    }
    
    // Add handrails to staircase
    staircase = staircase.fuse(leftHandrail).fuse(rightHandrail);
  }
  
  return staircase;
}`;

const tableCode = `/**
 * Parametric Table
 * A customizable table with adjustable dimensions, leg style options, and optional features.
 * Suitable for 3D printing, woodworking plans, or visualization.
 */
const defaultParams = {
  // Table dimensions
  width: 800,      // Width of the table in mm
  length: 1200,    // Length of the table in mm
  height: 750,     // Height of the table in mm
  
  // Table top
  topThickness: 25, // Thickness of the tabletop in mm
  roundedCorners: true, // Whether to create rounded corners on the tabletop
  cornerRadius: 50, // Radius for rounded corners (if enabled)
  
  // Legs
  legStyle: "square", // "square" or "round"
  legWidth: 50,      // Width/diameter of the legs in mm
  legInset: 25,      // Distance from edge to OUTER edge of leg
  
  // Apron (the frame under the tabletop)
  includeApron: true, // Whether to include an apron
  apronHeight: 80,    // Height of the apron in mm
  apronThickness: 20, // Thickness of the apron in mm
  
  // Additional features
  includeShelf: false, // Whether to include a lower shelf
  shelfHeight: 150,    // Height from floor to shelf in mm
  shelfThickness: 15,  // Thickness of the shelf in mm
  shelfInset: 50,      // Inset of shelf from edges
};

const { drawRoundedRectangle, drawCircle, draw } = replicad;

/**
 * Creates the tabletop of the table
 * @param p - Parameters for the table
 * @returns The tabletop 3D shape
 */
function createTabletop(p) {
  // Create tabletop at the exact final height
  if (p.roundedCorners) {
    return drawRoundedRectangle(p.width, p.length, p.cornerRadius)
      .sketchOnPlane()
      .extrude(p.topThickness)
      .translate([0, 0, p.height - p.topThickness]);
  } else {
    return draw([-p.width/2, -p.length/2])
      .hLine(p.width)
      .vLine(p.length)
      .hLine(-p.width)
      .close()
      .sketchOnPlane()
      .extrude(p.topThickness)
      .translate([0, 0, p.height - p.topThickness]);
  }
}

/**
 * Creates a single leg for the table
 * @param p - Parameters for the table
 * @param x - X position of the leg
 * @param y - Y position of the leg
 * @returns The leg 3D shape
 */
function createLeg(p, x, y) {
  // Start legs from Z=0 and extrude up to meet the apron
  const legHeight = p.height - p.topThickness;
    
  if (p.legStyle === "round") {
    return drawCircle(p.legWidth / 2)
      .sketchOnPlane()
      .extrude(legHeight)
      .translate([x, y, 0]);
  } else {
    return draw([x - p.legWidth/2, y - p.legWidth/2])
      .hLine(p.legWidth)
      .vLine(p.legWidth)
      .hLine(-p.legWidth)
      .close()
      .sketchOnPlane()
      .extrude(legHeight)
      .translate([0, 0, 0]);
  }
}

/**
 * Creates all four legs for the table
 * @param p - Parameters for the table
 * @returns The combined legs 3D shape
 */
function createLegs(p) {
  // Calculate leg positions - now include legWidth for proper inset
  // For each leg, position the center so the outer edge is exactly legInset from table edge
  const legXPos = p.width/2 - p.legInset - p.legWidth/2;
  const legYPos = p.length/2 - p.legInset - p.legWidth/2;
  
  // Create all four legs
  const leg1 = createLeg(p, -legXPos, -legYPos);
  const leg2 = createLeg(p, legXPos, -legYPos);
  const leg3 = createLeg(p, legXPos, legYPos);
  const leg4 = createLeg(p, -legXPos, legYPos);
  
  // Combine legs into a single shape
  return leg1.fuse(leg2).fuse(leg3).fuse(leg4);
}

/**
 * Creates the apron frame under the tabletop
 * @param p - Parameters for the table
 * @returns The apron 3D shape or null if apron is disabled
 */
function createApron(p) {
  if (!p.includeApron) {
    return null;
  }
  
  // Calculate leg positions
  const legXPos = p.width/2 - p.legInset - p.legWidth/2;
  const legYPos = p.length/2 - p.legInset - p.legWidth/2;
  
  // Position the apron to meet exactly with the bottom of the tabletop
  const apronZ = p.height - p.topThickness - p.apronHeight;
  
  // Calculate the positions of the leg corners that the apron should connect to
  const legHalfWidth = p.legWidth / 2;
  
  // Front apron (Y-) - extends from left leg to right leg
  const frontApron = draw([-legXPos - legHalfWidth, -legYPos - legHalfWidth])
    .hLine(2 * legXPos + p.legWidth)  // Full width between outer edges of legs
    .vLine(p.apronThickness)
    .hLine(-(2 * legXPos + p.legWidth))
    .close()
    .sketchOnPlane()
    .extrude(p.apronHeight)
    .translate([0, 0, apronZ]);
    
  // Back apron (Y+) - extends from left leg to right leg
  const backApron = draw([-legXPos - legHalfWidth, legYPos + legHalfWidth - p.apronThickness])
    .hLine(2 * legXPos + p.legWidth)
    .vLine(p.apronThickness)
    .hLine(-(2 * legXPos + p.legWidth))
    .close()
    .sketchOnPlane()
    .extrude(p.apronHeight)
    .translate([0, 0, apronZ]);
    
  // Left apron (X-) - extends from front leg to back leg
  const leftApron = draw([-legXPos - legHalfWidth, -legYPos - legHalfWidth + p.apronThickness])
    .hLine(p.apronThickness)
    .vLine(2 * legYPos + p.legWidth - p.apronThickness)
    .hLine(-p.apronThickness)
    .close()
    .sketchOnPlane()
    .extrude(p.apronHeight)
    .translate([0, 0, apronZ]);
    
  // Right apron (X+) - extends from front leg to back leg
  const rightApron = draw([legXPos + legHalfWidth - p.apronThickness, -legYPos - legHalfWidth + p.apronThickness])
    .hLine(p.apronThickness)
    .vLine(2 * legYPos + p.legWidth - p.apronThickness)
    .hLine(-p.apronThickness)
    .close()
    .sketchOnPlane()
    .extrude(p.apronHeight)
    .translate([0, 0, apronZ]);
  
  // Combine apron sides
  return frontApron.fuse(backApron).fuse(leftApron).fuse(rightApron);
}

/**
 * Creates an optional lower shelf for the table
 * @param p - Parameters for the table
 * @returns The shelf 3D shape or null if shelf is disabled
 */
function createShelf(p) {
  if (!p.includeShelf) {
    return null;
  }
  
  // Calculate shelf dimensions with inset
  const shelfWidth = p.width - 2 * p.shelfInset;
  const shelfLength = p.length - 2 * p.shelfInset;
  
  // Create the shelf shape at exact specified height
  if (p.roundedCorners) {
    const shelfRadius = Math.min(p.cornerRadius * 0.8, Math.min(shelfWidth, shelfLength) * 0.2);
    
    return drawRoundedRectangle(shelfWidth, shelfLength, shelfRadius)
      .sketchOnPlane()
      .extrude(p.shelfThickness)
      .translate([0, 0, p.shelfHeight]);
  } else {
    return draw([-shelfWidth/2, -shelfLength/2])
      .hLine(shelfWidth)
      .vLine(shelfLength)
      .hLine(-shelfWidth)
      .close()
      .sketchOnPlane()
      .extrude(p.shelfThickness)
      .translate([0, 0, p.shelfHeight]);
  }
}

/**
 * Creates a parametric table with customizable features
 * @param _ - Unused parameter (required by replicad)
 * @param params - Custom parameters to override defaults
 * @returns The complete table model
 */
function main(_, params) {
  // Merge default parameters with provided ones
  const p = { ...defaultParams, ...params };
  
  // Create table components
  const tabletop = createTabletop(p);
  const legs = createLegs(p);
  let table = tabletop.fuse(legs);
  
  // Add optional apron
  if (p.includeApron) {
    const apron = createApron(p);
    if (apron) {
      table = table.fuse(apron);
    }
  }
  
  // Add optional shelf
  if (p.includeShelf) {
    const shelf = createShelf(p);
    if (shelf) {
      table = table.fuse(shelf);
    }
  }
  
  return table;
}`;

const legoCode = `
/**
 * Parametric LEGO Brick
 * A simplified and more robust version with standard LEGO dimensions.
 * Features hollow bottom for connecting to other bricks.
 */

const defaultParams = {
  // Basic brick dimensions in LEGO units
  width: 2,       // Number of studs wide
  length: 4,      // Number of studs long
  height: 1,      // Height (1 = standard brick, 1/3 = plate)
  
  // Standard LEGO dimensions in mm
  studDiameter: 4.8,
  studHeight: 1.8,
  wallThickness: 1.5,    // Increased for better stability
  baseThickness: 1.2,    // Slightly thicker base
  
  // Tube dimensions
  tubeOuterDiameter: 6.5,
  tubeInnerDiameter: 4.8,
  tubeHeight: 8.0 - 1.2, // Full height minus base thickness
  
  // Base unit (1 LEGO unit = 8mm)
  unit: 8.0,
  
  // Features
  withTubes: true,      // Include bottom tubes
  rounded: false,       // Simplified version without rounds
};

const { 
  drawCircle, 
  drawRectangle,
  draw
} = replicad;

/**
 * Creates a single stud
 * @param p Parameters object
 * @returns The stud shape
 */
function createStud(p) {
  return drawCircle(p.studDiameter / 2)
    .sketchOnPlane()
    .extrude(p.studHeight);
}

/**
 * Creates a bottom tube (hollow cylinder)
 * @param p Parameters object
 * @returns The tube shape
 */
function createBottomTube(p) {
  const outer = drawCircle(p.tubeOuterDiameter / 2)
    .sketchOnPlane()
    .extrude(p.tubeHeight);
    
  const inner = drawCircle(p.tubeInnerDiameter / 2)
    .sketchOnPlane()
    .extrude(p.tubeHeight);
    
  return outer.cut(inner);
}

/**
 * Determines tube positions for any brick size
 * @param width Number of studs wide
 * @param length Number of studs long
 * @returns Array of [x,y] positions for tubes
 */
function calculateTubePositions(width, length) {
  const positions = [];
  
  if (width === 1) {
    // 1-wide bricks don't have tubes
    return positions;
  }
  
  // if (width === 2) {
  //   // 2-wide bricks have tubes only in center line
  //   const numTubes = length - 1;
  //   for (let i = 0; i < numTubes; i++) {
  //     positions.push([0, i - (numTubes - 1) / 2]);
  //   }
  //   return positions;
  // }
  
  // For wider bricks, create appropriate grid of tubes
  // Skip outer edges, place tubes in interior
  // For wider bricks, place tubes at intersection of 4 studs
  for (let x = 0; x < width - 1; x++) {
    for (let y = 0; y < length - 1; y++) {
      // Convert to centered coordinates and offset by 0.5 to place between studs
      const xPos = (x - (width - 2) / 2);
      const yPos = (y - (length - 2) / 2);
      positions.push([xPos, yPos]);
    }
  }
  
  return positions;
}

/**
 * Creates a LEGO brick with hollow bottom
 * @param _ Unused parameter
 * @param params Custom parameters
 * @returns The LEGO brick model
 */
function main(_, params) {
  // Merge parameters
  const p = { ...defaultParams, ...params };
  
  // Calculate dimensions
  const totalWidth = p.width * p.unit;
  const totalLength = p.length * p.unit;
  const totalHeight = p.height * p.unit;
  
  // Create main body
  const brickBody = drawRectangle(
    totalWidth,
    totalLength
  )
    .sketchOnPlane()
    .extrude(totalHeight);
  
  // Create bottom hollow
  const hollowWidth = totalWidth - 2 * p.wallThickness;
  const hollowLength = totalLength - 2 * p.wallThickness;
  const hollowHeight = totalHeight - p.baseThickness;
  
  const bottomHollow = drawRectangle(
    hollowWidth,
    hollowLength
  )
    .sketchOnPlane()
    .extrude(hollowHeight);
  
  // Start building the brick
  let brick = brickBody;
  
  // Add studs
  for (let x = 0; x < p.width; x++) {
    for (let y = 0; y < p.length; y++) {
      const xPos = (x - (p.width - 1) / 2) * p.unit;
      const yPos = (y - (p.length - 1) / 2) * p.unit;
      
      const stud = createStud(p).translate([xPos, yPos, totalHeight]);
      brick = brick.fuse(stud);
    }
  }
  
  // Cut out the bottom hollow
  brick = brick.cut(
    bottomHollow.translate([0, 0, 0])
  );
  
  // Add bottom tubes
  if (p.withTubes) {
    const tubePositions = calculateTubePositions(p.width, p.length);
    
    for (const [x, y] of tubePositions) {
      const xPos = x * p.unit;
      const yPos = y * p.unit;
      
      const tube = createBottomTube(p).translate([xPos, yPos, 0]);
      brick = brick.fuse(tube);
    }
  }
  
  return brick;
}
`;

export const mockModels = [
  {
    id: 'bld_birdhouse',
    name: 'Birdhouse',
    code: birdhouseCode,
  },
  {
    id: 'bld_tray',
    name: 'Tray',
    code: trayCode,
  },
  {
    id: 'bld_vase',
    name: 'Vase',
    code: vaseCode,
  },
  {
    id: 'bld_wavy-vase',
    name: 'Wavy Vase',
    code: wavyVase,
  },
  {
    id: 'bld_cylindrical-gear',
    name: 'Cycloidal Gear',
    code: cycloidalGear,
  },
  {
    id: 'bld_bottle',
    name: 'Bottle',
    code: bottle,
  },
  {
    id: 'bld_gridfinity-box',
    name: 'Gridfinity Box',
    code: gridfinityBox,
  },
  {
    id: 'bld_decorated-box',
    name: 'Decorated Box',
    code: decoratedBox,
  },
  {
    id: 'bld_card-holder',
    name: 'Card Holder',
    code: cardHolderCode,
  },
  {
    id: 'bld_staircase',
    name: 'Staircase',
    code: staircaseCode,
  },
  {
    id: 'bld_table',
    name: 'Table',
    code: tableCode,
  },
  {
    id: 'bld_lego',
    name: 'Lego',
    code: legoCode,
  },
] satisfies Model[];
