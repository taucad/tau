/* eslint-disable no-useless-escape -- required for the precompiled grammar */
/* eslint-disable @typescript-eslint/naming-convention -- required for the precompiled grammar */
/**
 * Precompiled KCL language for Shiki.
 *
 * This is a precompiled version of the KCL language for Shiki.
 * It is used to highlight KCL code in the Monaco editor.
 *
 * This file is generated by a custom script:
 * `npx tsx precompile-grammar.ts ./apps/ui/app/lib/kcl/kcl.tmLanguage.json`
 *
 * @see https://github.com/taucad/shiki/blob/main/README-precompile.md
 *
 * The original Textmate grammar is sourced from: https://github.com/KittyCAD/kcl.tmbundle/tree/main
 * Notes:
 * - The original is a plist file that is converted to a JSON file.
 * - Additional built-in functions are added to the grammar.
 * - Support is added for multi-line comments.
 *
 * TODO: add the original grammar to the Shiki project.
 */

const lang = Object.freeze({
  name: 'kcl',
  scopeName: 'source.kcl',
  displayName: 'KCL',
  fileTypes: ['kcl'],
  aliases: undefined,
  patterns: [
    {
      name: 'comment.block.kcl',
      begin: /\/\*/dgv,
      end: /\*\//dgv,
      beginCaptures: { '0': { name: 'punctuation.definition.comment.begin.kcl' } },
      endCaptures: { '0': { name: 'punctuation.definition.comment.end.kcl' } },
    },
    { name: 'comment.line.double-slash.kcl', match: /\/\/[^\n]*(?=\n?$)/dgv },
    { name: 'keyword.control.conditional.kcl', match: /\b(if|else if|else)\b/dgv },
    { name: 'keyword.control.conditional.kcl', match: /\b(if|else if|else)\b/dgv },
    { name: 'keyword.control.return.kcl', match: /\breturn\b/dgv },
    { name: 'keyword.declaration.kcl', match: /\b(var|let|const)\b/dgv },
    { name: 'keyword.operator.comparison.kcl', match: /(==|!=|<=|>=|<|>)/dgv },
    { name: 'keyword.operator.definition.kcl', match: /=/dgv },
    {
      name: 'meta.module.import.statement.kcl',
      begin: /\b(import)\p{space}+(?=[\p{L}\p{M}\p{N}\p{Pc}]+)/dgv,
      beginCaptures: { '1': { name: 'keyword.module.import.kcl' } },
      end: /\b(from)\p{space}+('[^']*'|"[^"]*")/dgv,
      endCaptures: { '1': { name: 'keyword.module.import.from.kcl' }, '2': { name: 'string.quoted.module.kcl' } },
      patterns: [{ include: '#import-item' }, { name: 'punctuation.separator.comma.kcl', match: /,/dgv }],
    },
    { name: 'keyword.module.import.kcl', match: /\bimport\b/dgv },
    { name: 'entity.name.tag.kcl', match: /\$[\p{L}\p{M}\p{N}\p{Pc}]+\b/dgv },
    { name: 'keyword.directive.settings.kcl', match: /@[\p{L}\p{M}\p{N}\p{Pc}]+\b/dgv },
    {
      name: 'meta.function.definition.kcl',
      begin: /\b((export)\p{space}+)?(fn)\p{space}+([\p{L}\p{M}\p{N}\p{Pc}]+)\p{space}*(=)/dgv,
      beginCaptures: {
        '1': { name: 'storage.modifier.visibility.kcl' },
        '3': { name: 'keyword.control.function.kcl' },
        '4': { name: 'entity.name.function.kcl' },
        '5': { name: 'keyword.operator.definition.kcl' },
      },
      end: /\{/dgv,
      endCaptures: { '0': { name: 'punctuation.section.block.begin.kcl' } },
      patterns: [
        {
          name: 'meta.parameters.kcl',
          begin: /\(/dgv,
          beginCaptures: { '0': { name: 'punctuation.section.parameters.begin.kcl' } },
          end: /\)/dgv,
          endCaptures: { '0': { name: 'punctuation.section.parameters.end.kcl' } },
          patterns: [
            { name: 'variable.parameter.kcl', match: /\b[\p{L}\p{M}\p{N}\p{Pc}]+\b/dgv },
            { name: 'punctuation.separator.parameter.function.kcl', match: /,/dgv },
          ],
        },
        { name: 'keyword.operator.fat-arrow.kcl', match: /=>/dgv },
      ],
    },
    { include: '#anonymous-function' },
    {
      name: 'string.quoted.double.kcl',
      begin: /"/dgv,
      end: /"/dgv,
      beginCaptures: { '0': { name: 'punctuation.definition.string.begin.kcl' } },
      endCaptures: { '0': { name: 'punctuation.definition.string.end.kcl' } },
      patterns: [{ name: 'constant.character.escape.kcl', match: /\\[^\n]/dgv }],
    },
    {
      name: 'string.quoted.single.kcl',
      begin: /'/dgv,
      end: /'/dgv,
      beginCaptures: { '0': { name: 'punctuation.definition.string.begin.kcl' } },
      endCaptures: { '0': { name: 'punctuation.definition.string.end.kcl' } },
      patterns: [{ name: 'constant.character.escape.kcl', match: /\\[^\n]/dgv }],
    },
    { name: 'keyword.operator.control.pipeline.kcl', match: /\|>/dgv },
    { name: 'variable.language.pipe-substitution.kcl', match: /%/dgv },
    { match: /\b(true|false)\b/dgv, name: 'constant.language.kcl' },
    { name: 'constant.numeric.kcl', match: /(\b\p{Nd}+(\.\p{Nd}+)?|\.\p{Nd}+)\b/dgv },
    { name: 'keyword.operator.arithmetic.kcl', match: /[\+\-\*\/\^]/dgv },
    { name: 'support.constant.prelude.kcl', match: /\b(ZERO|QUARTER_TURN|HALF_TURN|THREE_QUARTER_TURN)\b/dgv },
    {
      name: 'support.function.stdlib.kcl',
      match:
        /\b(abs|acos|appearance|arc|angledLine|angledLineOfXLength|angledLineOfYLength|angledLineThatIntersects|angledLineToX|angledLineToY|angleToMatchLengthX|angleToMatchLengthY|arc|asin|assert|assertEqual|assertGreaterThan|assertGreaterThanOrEq|assertLessThan|assertLessThanOrEq|atan|bezierCurve|ceil|chamfer|circle|clone|close|cm|cos|e|extrude|fillet|floor|ft|getNextAdjacentEdge|getOppositeEdge|getPreviousAdjacentEdge|helix|hole|hollow|import|inch|int|lastSegX|lastSegY|legAngX|legAngY|legLen|line|lineTo|ln|loft|log|log10|log2|m|map|max|min|mirror2d|mm|offsetPlane|patternCircular2d|patternCircular3d|patternLinear2d|patternLinear3d|patternTransform|pi|polar|polygon|pow|profileStart|profileStartX|profileStartY|push|reduce|rem|revolve|rotate|segAng|segEnd|segEndX|segEndY|segLen|segStart|segStartX|segStartY|shell|sin|sqrt|startProfile|startProfileAt|startSketchAt|startSketchOn|tan|tangentialArc|tangentialArcTo|tangentialArcToRelative|tau|toDegrees|toRadians|translate|xLine|xLineTo|yd|yLine|yLineTo)\b/dgv,
    },
    { name: 'punctuation.section.array.begin.kcl', match: /\[/dgv },
    { name: 'punctuation.section.array.end.kcl', match: /\]/dgv },
    { name: 'punctuation.separator.colon.kcl', match: /:/dgv },
    { name: 'punctuation.separator.comma.kcl', match: /,/dgv },
    { name: 'variable.other.kcl', match: /\b([\p{L}\p{M}\p{N}\p{Pc}]+)\b/dgv },
  ],
  repository: {
    'import-item': {
      name: 'meta.module.import.item.kcl',
      match: /\b([\p{L}\p{M}\p{N}\p{Pc}]+)(?:\p{space}+(as)\p{space}+([\p{L}\p{M}\p{N}\p{Pc}]+))?/dgv,
      captures: {
        '1': { name: 'variable.import.kcl' },
        '2': { name: 'keyword.module.import.item.as.kcl' },
        '3': { name: 'variable.import.alias.kcl' },
      },
    },
    'anonymous-function': {
      name: 'meta.function.anonymous.kcl',
      begin:
        /(\()(?=\p{space}*[\p{L}\p{M}\p{N}\p{Pc}]+(?:\p{space}*,\p{space}*[\p{L}\p{M}\p{N}\p{Pc}]+)*\)\p{space}*=>)/dgv,
      beginCaptures: { '1': { name: 'punctuation.section.parameters.begin.kcl' } },
      end: /(=>)\p{space}*(\{)/dgv,
      endCaptures: {
        '1': { name: 'keyword.operator.fat-arrow.kcl' },
        '2': { name: 'punctuation.section.block.begin.kcl' },
      },
      patterns: [
        { name: 'variable.parameter.kcl', match: /\b[\p{L}\p{M}\p{N}\p{Pc}]+\b/dgv },
        { name: 'punctuation.separator.parameter.function.kcl', match: /,/dgv },
        { name: 'punctuation.section.parameters.end.kcl', match: /\)/dgv },
      ],
    },
  },
  embeddedLangs: [],
});

const langs = [lang];

export default langs;
