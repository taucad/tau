/* eslint-disable no-useless-escape -- required for the precompiled grammar */
/* eslint-disable @typescript-eslint/naming-convention -- required for the precompiled grammar */
/**
 * Precompiled OpenSCAD language for Shiki.
 *
 * This is a precompiled version of the OpenSCAD language for Shiki.
 * It is used to highlight OpenSCAD code in the Monaco editor.
 *
 * This file is generated by a custom script:
 * `npx tsx precompile-grammar.ts ./apps/ui/app/lib/openscad-language/openscad.tmLanguage.json`
 *
 * @see https://github.com/taucad/shiki/blob/main/README-precompile.md
 *
 * The original Textmate grammar is sourced from:
 * - https://github.com/Leathong/openscad-support-vscode/blob/master/syntaxes/scad.tmLanguage.json
 *
 * TODO: add the original grammar to the Shiki project.
 */

const lang = Object.freeze({
  name: 'scad',
  scopeName: 'source.scad',
  displayName: 'OpenSCAD',
  aliases: ['openscad'],
  fileTypes: ['scad'],
  patterns: [
    { include: '#comments' },
    {
      name: 'invalid.string.quoted.single.scad',
      begin: /'/dgv,
      beginCaptures: { '0': { name: 'punctuation.definition.string.begin.scad' } },
      end: /'/dgv,
      endCaptures: { '0': { name: 'punctuation.definition.string.end.scad' } },
      patterns: [
        {
          name: 'constant.character.escape.scad',
          match: /\\(x[0-7]?[0-9A-Fa-f]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{6}|[^\n])/dgv,
        },
      ],
    },
    {
      name: 'string.quoted.double.scad',
      begin: /"/dgv,
      beginCaptures: { '0': { name: 'punctuation.definition.string.begin.scad' } },
      end: /"/dgv,
      endCaptures: { '0': { name: 'punctuation.definition.string.end.scad' } },
      patterns: [
        {
          name: 'constant.character.escape.scad',
          match: /\\(x[0-7]?[0-9A-Fa-f]|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{6}|[^\n])/dgv,
        },
      ],
    },
    { include: '#include' },
    { name: 'invalid.deprecated', match: /\b(assign|child|import_dxf|import_stl)\b/dgv },
    { name: 'punctuation.terminator.statement.scad', match: /;/dgv },
    { name: 'meta.delimiter.object.comma.scad', match: /,[ \|\t]*/dgv },
    { name: 'meta.dot.scad', match: /\.(?![0-9])/dgv },
    { include: '#brace_block' },
    { include: '#bracket_block' },
    { include: '#paren_block' },
    { name: 'keyword.operator.assignment.scad', match: /=(?!=)/dgv },
    { name: 'keyword.operator.arithmetic.scad', match: /\+|-|\*|\/|%/dgv },
    { name: 'keyword.operator.logical.scad', match: /!|&&|\|\|/dgv },
    { name: 'keyword.operator.relational.scad', match: /<=|<|==|!=|>=|>/dgv },
    { name: 'keyword.operator.conditional.scad', match: /\?|:/dgv },
    { name: 'keyword.operator.other.scad', match: /#|%|!/dgv },
    { name: 'variable.language.scad', match: /\$(children|fn|fa|fs|t|preview|vpr|vpt|vpf|vpd|parent_modules)\b/dgv },
    { include: '#constants' },
    { include: '#keyword_control' },
    {
      comment: 'Ummm... why do we have three of these? This is one...',
      name: 'constant.numeric.float.scad',
      match: /\b(\p{Nd}+\.\p{Nd}*(e[\-\+]?\p{Nd}+)?)(?=[^\p{Alpha}_])/dgiv,
    },
    {
      comment: 'This is two...',
      name: 'constant.numeric.float.scad',
      match: /(?<=[^\p{Alpha}\p{Nd}_])(\.\p{Nd}+(e[\-\+]?\p{Nd}+)?)/dgiv,
    },
    { comment: 'And this is three...', name: 'constant.numeric.float.scad', match: /\b(\p{Nd}+e[\-\+]?\p{Nd}+)/dgiv },
    { name: 'constant.numeric.integer.decimal.scad', match: /\b([1-9]+[0-9]*|0)/dgv },
    {
      name: 'meta.function.scad',
      begin: /\b(((?:module|function)))\p{space}+(?=[\p{Alpha}_][\p{Alpha}\p{Nd}_]*)\p{space}*(?=\()/dgv,
      beginCaptures: { '1': { name: 'storage.type.$2.scad' } },
      end: /(?<=\))/dgv,
      endCaptures: { '1': { name: 'punctuation.definition.parameters.begin.scad' } },
      patterns: [
        {
          contentName: 'entity.name.function.scad',
          begin: /(?=[\p{Alpha}_][\p{Alpha}\p{Nd}_]*)/dgv,
          end: /(?![\p{Alpha}\p{Nd}_])/dgv,
          patterns: [{ include: '#illegal_names' }],
        },
        {
          contentName: 'meta.function.parameters.scad',
          begin: /(\()/dgv,
          beginCaptures: { '1': { name: 'punctuation.definition.parameters.begin.scad' } },
          end: /(?=\))/dgv,
          patterns: [
            { include: '#keyword_arguments' },
            { include: '#illegal_names' },
            {
              match: /\b([\p{Alpha}_][\p{Alpha}\p{Nd}_]*)\p{space}*(?:(,)|(?=[\n\)]))/dgv,
              captures: {
                '1': { name: 'variable.parameter.function.language.scad' },
                '2': { name: 'punctuation.separator.parameters.scad' },
                '3': { name: 'punctuation.separator.parameters.scad' },
              },
            },
          ],
        },
        {
          begin: /(\))/dgv,
          beginCaptures: { '1': { name: 'punctuation.definition.parameters.end.scad' } },
          end: /(?<=\))/dgv,
          patterns: [{ include: '$self' }],
        },
      ],
    },
    { match: /\b((module|function))\b/dgv, captures: { '1': { name: 'storage.type.$2.scad' } } },
    {
      name: 'meta.function-call.scad',
      begin: /(?:\.)?([\p{Alpha}_][\p{Alpha}\p{Nd}_]*)\p{space}*(?=(\())/dgv,
      beginCaptures: {
        '1': { name: 'entity.name.function.call.scad' },
        '2': { name: 'punctuation.definition.arguments.begin.scad' },
      },
      end: /(\))/dgv,
      endCaptures: { '1': { name: 'punctuation.definition.arguments.end.scad' } },
      patterns: [
        {
          contentName: 'meta.function-call.arguments.scad',
          begin: /(\()/dgv,
          beginCaptures: { '1': { name: 'punctuation.definition.arguments.begin.scad' } },
          end: /(?=(\)))/dgv,
          endCaptures: { '1': { name: 'punctuation.definition.arguments.end.scad' } },
          patterns: [{ include: '#keyword_arguments' }, { include: '$self' }],
        },
      ],
    },
    { include: '#let_keyword' },
    { include: '#function_builtin' },
  ],
  repository: {
    brace_block: {
      name: 'meta.block.scad',
      begin: /\{/dgv,
      end: /\}/dgv,
      beginCaptures: { '0': { name: 'punctuation.section.block.begin.bracket.curly.scad' } },
      endCaptures: { '0': { name: 'punctuation.section.block.end.bracket.curly.scad' } },
      patterns: [{ include: '$self' }],
    },
    bracket_block: {
      name: 'meta.block.scad',
      begin: /\[/dgv,
      end: /\]/dgv,
      beginCaptures: { '0': { name: 'punctuation.section.block.begin.bracket.square.scad' } },
      endCaptures: { '0': { name: 'punctuation.section.block.end.bracket.square.scad' } },
      patterns: [{ include: '$self' }],
    },
    comments: {
      patterns: [
        { include: '#export_name_format' },
        { include: '#customizer_comments' },
        {
          name: 'comment.block.documentation.scad',
          begin: /\/\*\*(?!\/)/dgv,
          captures: { '0': { name: 'punctuation.definition.comment.scad' } },
          end: /\*\//dgv,
        },
        {
          name: 'comment.block.scad',
          begin: /\/\*/dgv,
          captures: { '0': { name: 'punctuation.definition.comment.scad' } },
          end: /\*\//dgv,
        },
        {
          name: 'comment.line.double-slash.scad',
          match: /(\/\/)[^\n]*(?=\n?$)\n?/dgv,
          captures: { '1': { name: 'punctuation.definition.comment.scad' } },
        },
      ],
    },
    constants: {
      patterns: [
        { name: 'constant.language.boolean.true.scad', match: /\btrue\b/dgv },
        { name: 'constant.language.boolean.false.scad', match: /\bfalse\b/dgv },
        { name: 'constant.language.undef.scad', match: /\bundef\b/dgv },
        { name: 'constant.language.pi.scad', match: /\bPI\b/dgv },
      ],
    },
    customizer_comments: {
      patterns: [
        {
          name: 'comment.block.scad',
          match: /(\/\*(?:\*)?(?!\/))([^\n]*?)(\*\/)/dgv,
          captures: {
            '1': { name: 'punctuation.definition.comment.begin.scad' },
            '2': { patterns: [{ begin: /\[/dgv, end: /\]/dgv, name: 'keyword.other.customizer.scad' }] },
            '3': { name: 'punctuation.definition.comment.end.scad' },
          },
        },
        {
          name: 'comment.line.double-slash.scad',
          match:
            /(?<=\P{space}\p{space}*)(\/\/\p{space}*)(\[(?:-?\p{Nd}+(?:[^\n]\p{Nd})*(?:\p{space}*:\p{space}*-?\p{Nd}+(?:[^\n]\p{Nd})*){0,2}|(?:(?:[^\:\,]+:)?[^\:\,]+,)*(?:[^\:\,]+:)?[^\:\,]+)\])[ \t]*(?=\n?$)\n?/dgv,
          captures: {
            '1': { name: 'punctuation.definition.comment.scad' },
            '2': { name: 'keyword.other.customizer.scad' },
          },
        },
      ],
    },
    export_name_format: {
      name: 'comment.line.double-slash.scad',
      match: /(\/\/\p{space}*)(exportNameFormat)\p{space}*=\p{space}*([^\n]*)/dgv,
      captures: {
        '1': { name: 'punctuation.definition.comment.scad' },
        '2': { name: 'keyword.other.config.exportNameFormat.scad' },
        '3': {
          patterns: [
            {
              match: /\$\{[\p{L}\p{M}\p{N}\p{Pc}\#]+(:[^\n]*?)?\}/dgv,
              name: 'constant.character.format.exportNameFormat.scad',
            },
          ],
        },
      },
    },
    function_builtin: {
      patterns: [
        {
          name: 'support.function.scad',
          match: /\b(concat|lookupstr|chr|ord|search|version|version_num|parent_module)\b/dgv,
        },
        { name: 'support.function.scad', match: /\b(children|echo|group|offset|render)\b/dgv },
        { name: 'support.function.type-test.scad', match: /\b(is_undef|is_bool|is_num|is_string|is_list)\b/dgv },
        {
          name: 'support.function.math.scad',
          match: /\b(abs|sign|floor|round|ceil|ln|len|log|pow|sqrt|exp|rands|min|max|norm|cross)\b/dgv,
        },
        { name: 'support.function.math.trig.scad', match: /\b(sin|cos|asin|acos|tan|atan|atan2)\b/dgv },
        {
          name: 'support.function.transform.scad',
          match: /\b(scale|translate|rotate|multmatrix|color|projection|hull|resize|mirror|minkowski)\b/dgv,
        },
        { name: 'support.function.boolean.scad', match: /\b(union|difference|intersection)\b/dgv },
        { name: 'support.function.prim3d.scad', match: /\b(cube|sphere|cylinder|polyhedron)\b/dgv },
        { name: 'support.function.prim2d.scad', match: /\b(square|circle|polygon|text)\b/dgv },
        { name: 'support.function.extrude.scad', match: /\b(linear_extrude|rotate_extrude)\b/dgv },
      ],
    },
    include: {
      match: /\b(((?:include|use)))\p{space}*((<)[^\>]*(>?))/dgv,
      captures: {
        '1': { name: 'keyword.control.$2.scad' },
        '3': { name: 'string.quoted.other.lt-gt.include.scad' },
        '4': { name: 'punctuation.definition.string.begin.scad' },
        '5': { name: 'punctuation.definition.string.begin.scad' },
      },
    },
    illegal_names: {
      name: 'invalid.illegal.name.scad',
      match: /\b(true|false|module|function|include|use|undef|for|intersection_for|if|else|let)\b/dgv,
    },
    keyword_control: {
      patterns: [
        { name: 'keyword.control.scad', match: /\b(for|intersection_for|each|assert)\b/dgv },
        { name: 'keyword.control.conditional.scad', match: /\b(if|else)\b/dgv },
        { name: 'keyword.control.import.scad', match: /\b(import|dxf_dim|dxf_cross|surface)\b/dgv },
      ],
    },
    keyword_arguments: {
      comment: 'Incorporated from PythonImproved grammar',
      begin: /\b([\p{Alpha}_][\p{Alpha}\p{Nd}_]*)\p{space}*(=)(?!=)/dgv,
      beginCaptures: {
        '1': { name: 'variable.parameter.function.keyword.scad' },
        '2': { name: 'keyword.operator.assignment.scad' },
      },
      end: /\p{space}*(?:(,)|(?=\)))/dgv,
      endCaptures: { '1': { name: 'punctuation.separator.parameters.scad' } },
      patterns: [{ include: '$self' }],
    },
    let_keyword: { name: 'keyword.control.scad', match: /\b(let)\b/dgv },
    paren_block: {
      name: 'meta.block.parens.scad',
      begin: /\(/dgv,
      end: /\)/dgv,
      beginCaptures: { '0': { name: 'punctuation.section.parens.begin.bracket.round.scad' } },
      endCaptures: { '0': { name: 'punctuation.section.parens.end.bracket.round.scad' } },
      patterns: [{ include: '$self' }],
    },
  },
  embeddedLangs: [],
});

const langs = [lang];

export default langs;
