{
  "metadata": {
    "extractionDate": "2025-07-02T03:58:46.336Z",
    "extractionMethod": "TypeScript Compiler API (Filtered)",
    "totalApis": 202,
    "usedApis": 30,
    "filtering": {
      "removedPrivateProtected": true,
      "removedOcProperties": true,
      "removedUnderscorePrefixed": true
    }
  },
  "apis": [
    {
      "name": "translate",
      "type": "function",
      "category": "Transformations",
      "signature": "export declare function translate(shape: TopoDS_Shape, vector: Point): TopoDS_Shape;",
      "signatureWithJSDoc": "export declare function translate(shape: TopoDS_Shape, vector: Point): TopoDS_Shape;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        },
        {
          "name": "vector",
          "type": "Point",
          "optional": false
        }
      ],
      "returnType": "TopoDS_Shape",
      "usageCount": 54
    },
    {
      "name": "draw",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function draw(initialPoint?: Point2D): DrawingPen;",
      "signatureWithJSDoc": "/**\n * Creates a drawing pen to programatically draw in 2D.\n *\n * @category Drawing\n */\nexport declare function draw(initialPoint?: Point2D): DrawingPen;",
      "parameters": [
        {
          "name": "initialPoint",
          "type": "Point2D",
          "optional": true
        }
      ],
      "returnType": "DrawingPen",
      "usageCount": 34,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawCircle",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawCircle(radius: number): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of a circle.\n *\n * The circle is centered on [0, 0]\n *\n * @category Drawing\n */\nexport declare function drawCircle(radius: number): Drawing;",
      "parameters": [
        {
          "name": "radius",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Drawing",
      "usageCount": 32,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawRoundedRectangle",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawRoundedRectangle(width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of a rectangle with (optional) rounded corners.\n *\n * The rectangle is centered on [0, 0]\n *\n * @category Drawing\n */\nexport declare function drawRoundedRectangle(width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}): Drawing;",
      "parameters": [
        {
          "name": "width",
          "type": "number",
          "optional": false
        },
        {
          "name": "height",
          "type": "number",
          "optional": false
        },
        {
          "name": "r",
          "type": "number | {\r\n    rx?: number;\r\n    ry?: number;\r\n}",
          "optional": true
        }
      ],
      "returnType": "Drawing",
      "usageCount": 22,
      "jsDoc": "Drawing"
    },
    {
      "name": "EdgeFinder",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class EdgeFinder extends Finder3d<Edge> {\n    clone(): EdgeFinder;\n    inDirection(direction: Direction_2 | Point): this;\n    ofLength(length: number | ((l: number) => boolean)): this;\n    ofCurveType(curveType: CurveType): this;\n    parallelTo(plane: Plane | StandardPlane | Face): this;\n    inPlane(inputPlane: PlaneName | Plane, origin?: Point | number): this;\n    shouldKeep(element: Edge): boolean;\n}",
      "signatureWithJSDoc": "/**\n * With an EdgeFinder you can apply a set of filters to find specific edges\n * within a shape.\n *\n * @category Finders\n */\nexport declare class EdgeFinder extends Finder3d<Edge> {\n    clone(): EdgeFinder;\n    /**\n     * Filter to find edges that are in a certain direction\n     *\n     * @category Filter\n     */\n    inDirection(direction: Direction_2 | Point): this;\n    /**\n     * Filter to find edges of a certain length\n     *\n     * @category Filter\n     */\n    ofLength(length: number | ((l: number) => boolean)): this;\n    /**\n     * Filter to find edges that are of a cetain curve type.\n     *\n     * @category Filter\n     */\n    ofCurveType(curveType: CurveType): this;\n    /**\n     * Filter to find edges that are parallel to a plane.\n     *\n     * Note that this will work only in lines (but the method does not\n     * check this assumption).\n     *\n     * @category Filter\n     */\n    parallelTo(plane: Plane | StandardPlane | Face): this;\n    /**\n     * Filter to find edges that within a plane.\n     *\n     * Note that this will work only in lines (but the method does not\n     * check this assumption).\n     *\n     * @category Filter\n     */\n    inPlane(inputPlane: PlaneName | Plane, origin?: Point | number): this;\n    shouldKeep(element: Edge): boolean;\n}",
      "usageCount": 12,
      "jsDoc": "Finders"
    },
    {
      "name": "makePlane",
      "type": "function",
      "category": "Primitives & Makers",
      "signature": "export declare function makePlane(plane: Plane): Plane;",
      "signatureWithJSDoc": "export declare function makePlane(plane: Plane): Plane;",
      "parameters": [
        {
          "name": "plane",
          "type": "Plane",
          "optional": false
        }
      ],
      "returnType": "Plane",
      "usageCount": 9
    },
    {
      "name": "makePlane",
      "type": "function",
      "category": "Primitives & Makers",
      "signature": "export declare function makePlane(plane?: PlaneName, origin?: Point | number): Plane;",
      "signatureWithJSDoc": "export declare function makePlane(plane?: PlaneName, origin?: Point | number): Plane;",
      "parameters": [
        {
          "name": "plane",
          "type": "PlaneName",
          "optional": true
        },
        {
          "name": "origin",
          "type": "Point | number",
          "optional": true
        }
      ],
      "returnType": "Plane",
      "usageCount": 9
    },
    {
      "name": "FaceFinder",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class FaceFinder extends Finder3d<Face> {\n    clone(): FaceFinder;\n    parallelTo(plane: Plane | StandardPlane | Face): this;\n    ofSurfaceType(surfaceType: SurfaceType): this;\n    inPlane(inputPlane: PlaneName | Plane, origin?: Point | number): this;\n    shouldKeep(element: Face): boolean;\n}",
      "signatureWithJSDoc": "/**\n * With a FaceFinder you can apply a set of filters to find specific faces\n * within a shape.\n *\n * @category Finders\n */\nexport declare class FaceFinder extends Finder3d<Face> {\n    clone(): FaceFinder;\n    /** Filter to find faces that are parallel to plane or another face\n     *\n     * Note that this will work only in planar faces (but the method does not\n     * check this assumption).\n     *\n     * @category Filter\n     */\n    parallelTo(plane: Plane | StandardPlane | Face): this;\n    /**\n     * Filter to find faces that are of a cetain surface type.\n     *\n     * @category Filter\n     */\n    ofSurfaceType(surfaceType: SurfaceType): this;\n    /** Filter to find faces that are contained in a plane.\n     *\n     * Note that this will work only in planar faces (but the method does not\n     * check this assumption).\n     *\n     * @category Filter\n     */\n    inPlane(inputPlane: PlaneName | Plane, origin?: Point | number): this;\n    shouldKeep(element: Face): boolean;\n}",
      "usageCount": 8,
      "jsDoc": "Finders"
    },
    {
      "name": "rotate",
      "type": "function",
      "category": "Transformations",
      "signature": "export declare function rotate(shape: TopoDS_Shape, angle: number, position?: Point, direction?: Point): TopoDS_Shape;",
      "signatureWithJSDoc": "export declare function rotate(shape: TopoDS_Shape, angle: number, position?: Point, direction?: Point): TopoDS_Shape;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        },
        {
          "name": "angle",
          "type": "number",
          "optional": false
        },
        {
          "name": "position",
          "type": "Point",
          "optional": true
        },
        {
          "name": "direction",
          "type": "Point",
          "optional": true
        }
      ],
      "returnType": "TopoDS_Shape",
      "usageCount": 8
    },
    {
      "name": "drawRectangle",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const drawRectangle: typeof drawRoundedRectangle;",
      "signatureWithJSDoc": "export declare const drawRectangle: typeof drawRoundedRectangle;",
      "usageCount": 7
    },
    {
      "name": "sketchRectangle",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchRectangle: (xLength: number, yLength: number, planeConfig?: PlaneConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of a rectangle in a defined plane\n *\n * @category Sketching\n */\nexport declare const sketchRectangle: (xLength: number, yLength: number, planeConfig?: PlaneConfig) => Sketch;",
      "usageCount": 7,
      "jsDoc": "Sketching"
    },
    {
      "name": "assembleWire",
      "type": "constant",
      "category": "Finders & Filters",
      "signature": "export declare const assembleWire: (listOfEdges: (Edge | Wire)[]) => Wire;",
      "signatureWithJSDoc": "export declare const assembleWire: (listOfEdges: (Edge | Wire)[]) => Wire;",
      "usageCount": 5
    },
    {
      "name": "drawPolysides",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawPolysides(radius: number, sidesCount: number, sagitta?: number): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of an polygon in a defined plane\n *\n * The sides of the polygon can be arcs of circle with a defined sagitta.\n * The radius defines the out radius of the polygon without sagitta\n *\n * @category Drawing\n */\nexport declare function drawPolysides(radius: number, sidesCount: number, sagitta?: number): Drawing;",
      "parameters": [
        {
          "name": "radius",
          "type": "number",
          "optional": false
        },
        {
          "name": "sidesCount",
          "type": "number",
          "optional": false
        },
        {
          "name": "sagitta",
          "type": "number",
          "optional": true
        }
      ],
      "returnType": "Drawing",
      "usageCount": 5,
      "jsDoc": "Drawing"
    },
    {
      "name": "makeFace",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeFace: (wire: Wire, holes?: Wire[]) => Face;",
      "signatureWithJSDoc": "export declare const makeFace: (wire: Wire, holes?: Wire[]) => Face;",
      "usageCount": 5
    },
    {
      "name": "sketchCircle",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchCircle: (radius: number, planeConfig?: PlaneConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of a circle in a defined plane\n *\n * @category Sketching\n */\nexport declare const sketchCircle: (radius: number, planeConfig?: PlaneConfig) => Sketch;",
      "usageCount": 5,
      "jsDoc": "Sketching"
    },
    {
      "name": "makeSolid",
      "type": "function",
      "category": "Primitives & Makers",
      "signature": "export declare function makeSolid(facesOrShells: Array<Face | Shell>): Solid;",
      "signatureWithJSDoc": "/** Welds faces and shells into a single shell and then makes a solid.\n *\n * @param facesOrShells - An array of faces and shells to be welded.\n * @returns A solid that contains all the faces and shells.\n **/\nexport declare function makeSolid(facesOrShells: Array<Face | Shell>): Solid;",
      "parameters": [
        {
          "name": "facesOrShells",
          "type": "Array<Face | Shell>",
          "optional": false
        }
      ],
      "returnType": "Solid",
      "usageCount": 4,
      "jsDoc": "- An array of faces and shells to be welded. A solid that contains all the faces and shells."
    },
    {
      "name": "mirror",
      "type": "function",
      "category": "Transformations",
      "signature": "export declare function mirror(shape: TopoDS_Shape, inputPlane?: Plane | PlaneName | Point, origin?: Point): TopoDS_Shape;",
      "signatureWithJSDoc": "export declare function mirror(shape: TopoDS_Shape, inputPlane?: Plane | PlaneName | Point, origin?: Point): TopoDS_Shape;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        },
        {
          "name": "inputPlane",
          "type": "Plane | PlaneName | Point",
          "optional": true
        },
        {
          "name": "origin",
          "type": "Point",
          "optional": true
        }
      ],
      "returnType": "TopoDS_Shape",
      "usageCount": 4
    },
    {
      "name": "Plane",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Plane {\n    xDir: Vector;\n    yDir: Vector;\n    zDir: Vector;\n    constructor(origin: Point, xDirection?: Point | null, normal?: Point);\n    delete(): void;\n    clone(): Plane;\n    get origin(): Vector;\n    set origin(newOrigin: Vector);\n    translateTo(point: Point): Plane;\n    translate(xDist: number, yDist: number, zDist: number): Plane;\n    translate(vector: Point): Plane;\n    translateX(xDist: number): Plane;\n    translateY(yDist: number): Plane;\n    translateZ(zDist: number): Plane;\n    pivot(angle: number, direction?: Direction): Plane;\n    rotate2DAxes(angle: number): Plane;\n    setOrigin2d(x: number, y: number): void;\n    toLocalCoords(vec: Vector): Vector;\n    toWorldCoords(v: Point): Vector;\n}",
      "signatureWithJSDoc": "export declare class Plane {\n    xDir: Vector;\n    yDir: Vector;\n    zDir: Vector;\n    constructor(origin: Point, xDirection?: Point | null, normal?: Point);\n    delete(): void;\n    clone(): Plane;\n    get origin(): Vector;\n    set origin(newOrigin: Vector);\n    translateTo(point: Point): Plane;\n    translate(xDist: number, yDist: number, zDist: number): Plane;\n    translate(vector: Point): Plane;\n    translateX(xDist: number): Plane;\n    translateY(yDist: number): Plane;\n    translateZ(zDist: number): Plane;\n    pivot(angle: number, direction?: Direction): Plane;\n    rotate2DAxes(angle: number): Plane;\n    setOrigin2d(x: number, y: number): void;\n    toLocalCoords(vec: Vector): Vector;\n    toWorldCoords(v: Point): Vector;\n}",
      "usageCount": 4
    },
    {
      "name": "makeOffset",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeOffset: (face: Face, offset: number, tolerance?: number) => Shape3D;",
      "signatureWithJSDoc": "export declare const makeOffset: (face: Face, offset: number, tolerance?: number) => Shape3D;",
      "usageCount": 3
    },
    {
      "name": "Sketcher",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Sketcher implements GenericSketcher<Sketch> {\n    constructor(plane: Plane);\n    constructor(plane?: PlaneName, origin?: Point | number);\n    delete(): void;\n    movePointerTo([x, y]: Point2D): this;\n    lineTo([x, y]: Point2D): this;\n    line(xDist: number, yDist: number): this;\n    vLine(distance: number): this;\n    hLine(distance: number): this;\n    vLineTo(yPos: number): this;\n    hLineTo(xPos: number): this;\n    polarLine(distance: number, angle: number): this;\n    polarLineTo([r, theta]: [\n        number,\n        number\n    ]): this;\n    tangentLine(distance: number): this;\n    threePointsArcTo(end: Point2D, innerPoint: Point2D): this;\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    tangentArcTo(end: Point2D): this;\n    tangentArc(xDist: number, yDist: number): this;\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    vSagittaArc(distance: number, sagitta: number): this;\n    hSagittaArc(distance: number, sagitta: number): this;\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    vBulgeArc(distance: number, bulge: number): this;\n    hBulgeArc(distance: number, bulge: number): this;\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    halfEllipseTo(end: Point2D, verticalRadius: number, sweep?: boolean): this;\n    halfEllipse(xDist: number, yDist: number, verticalRadius: number, sweep?: boolean): this;\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    smoothSpline(xDist: number, yDist: number, splineConfig?: SplineConfig): this;\n    done(): Sketch;\n    close(): Sketch;\n    closeWithMirror(): Sketch;\n}",
      "signatureWithJSDoc": "/**\n * The FaceSketcher allows you to sketch on a plane.\n *\n * @category Sketching\n */\nexport declare class Sketcher implements GenericSketcher<Sketch> {\n    /**\n     * The sketcher can be defined by a plane, or a simple plane definition,\n     * with either a point of origin, or the position on the normal axis from\n     * the coordinates origin\n     */\n    constructor(plane: Plane);\n    constructor(plane?: PlaneName, origin?: Point | number);\n    delete(): void;\n    movePointerTo([x, y]: Point2D): this;\n    lineTo([x, y]: Point2D): this;\n    line(xDist: number, yDist: number): this;\n    vLine(distance: number): this;\n    hLine(distance: number): this;\n    vLineTo(yPos: number): this;\n    hLineTo(xPos: number): this;\n    polarLine(distance: number, angle: number): this;\n    polarLineTo([r, theta]: [\n        number,\n        number\n    ]): this;\n    tangentLine(distance: number): this;\n    threePointsArcTo(end: Point2D, innerPoint: Point2D): this;\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    tangentArcTo(end: Point2D): this;\n    tangentArc(xDist: number, yDist: number): this;\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    vSagittaArc(distance: number, sagitta: number): this;\n    hSagittaArc(distance: number, sagitta: number): this;\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    vBulgeArc(distance: number, bulge: number): this;\n    hBulgeArc(distance: number, bulge: number): this;\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    halfEllipseTo(end: Point2D, verticalRadius: number, sweep?: boolean): this;\n    halfEllipse(xDist: number, yDist: number, verticalRadius: number, sweep?: boolean): this;\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    smoothSpline(xDist: number, yDist: number, splineConfig?: SplineConfig): this;\n    done(): Sketch;\n    close(): Sketch;\n    closeWithMirror(): Sketch;\n}",
      "usageCount": 3,
      "jsDoc": "Sketching"
    },
    {
      "name": "drawParametricFunction",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const drawParametricFunction: (func: (t: number) => Point2D, { pointsCount, start, stop }?: {\n    pointsCount?: number | undefined;\n    start?: number | undefined;\n    stop?: number | undefined;\n}, approximationConfig?: BSplineApproximationConfig) => Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of parametric function\n *\n * The drawing will be a spline approximating the function. Note that the\n * degree should be at maximum 3 if you need to export the drawing as an SVG.\n *\n * @category Drawing\n */\nexport declare const drawParametricFunction: (func: (t: number) => Point2D, { pointsCount, start, stop }?: {\n    pointsCount?: number | undefined;\n    start?: number | undefined;\n    stop?: number | undefined;\n}, approximationConfig?: BSplineApproximationConfig) => Drawing;",
      "usageCount": 2,
      "jsDoc": "Drawing"
    },
    {
      "name": "makeCylinder",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeCylinder: (radius: number, height: number, location?: Point, direction?: Point) => Solid;",
      "signatureWithJSDoc": "export declare const makeCylinder: (radius: number, height: number, location?: Point, direction?: Point) => Solid;",
      "usageCount": 2
    },
    {
      "name": "polysideInnerRadius",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const polysideInnerRadius: (outerRadius: number, sidesCount: number, sagitta?: number) => number;",
      "signatureWithJSDoc": "/**\n * Helper function to compute the inner radius of a polyside (even if a sagitta\n * is defined\n */\nexport declare const polysideInnerRadius: (outerRadius: number, sidesCount: number, sagitta?: number) => number;",
      "usageCount": 2
    },
    {
      "name": "Shell",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Shell extends _3DShape<TopoDS_Shell> {\n}",
      "signatureWithJSDoc": "export declare class Shell extends _3DShape<TopoDS_Shell> {\n}",
      "usageCount": 2
    },
    {
      "name": "Vector",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Vector extends WrappingObj<gp_Vec> {\n    constructor(vector?: Point);\n    get repr(): string;\n    get x(): number;\n    get y(): number;\n    get z(): number;\n    get Length(): number;\n    toTuple(): [\n        number,\n        number,\n        number\n    ];\n    cross(v: Vector): Vector;\n    dot(v: Vector): number;\n    sub(v: Vector): Vector;\n    add(v: Vector): Vector;\n    multiply(scale: number): Vector;\n    normalized(): Vector;\n    normalize(): Vector;\n    getCenter(): Vector;\n    getAngle(v: Vector): number;\n    projectToPlane(plane: Plane): Vector;\n    equals(other: Vector): boolean;\n    toPnt(): gp_Pnt;\n    toDir(): gp_Dir;\n    rotate(angle: number, center?: Point, direction?: Point): Vector;\n}",
      "signatureWithJSDoc": "export declare class Vector extends WrappingObj<gp_Vec> {\n    constructor(vector?: Point);\n    get repr(): string;\n    get x(): number;\n    get y(): number;\n    get z(): number;\n    get Length(): number;\n    toTuple(): [\n        number,\n        number,\n        number\n    ];\n    cross(v: Vector): Vector;\n    dot(v: Vector): number;\n    sub(v: Vector): Vector;\n    add(v: Vector): Vector;\n    multiply(scale: number): Vector;\n    normalized(): Vector;\n    normalize(): Vector;\n    getCenter(): Vector;\n    getAngle(v: Vector): number;\n    projectToPlane(plane: Plane): Vector;\n    equals(other: Vector): boolean;\n    toPnt(): gp_Pnt;\n    toDir(): gp_Dir;\n    rotate(angle: number, center?: Point, direction?: Point): Vector;\n}",
      "usageCount": 2
    },
    {
      "name": "makeSphere",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeSphere: (radius: number) => Solid;",
      "signatureWithJSDoc": "export declare const makeSphere: (radius: number) => Solid;",
      "usageCount": 1
    },
    {
      "name": "revolution",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const revolution: (face: Face, center?: Point, direction?: Point, angle?: number) => Shape3D;",
      "signatureWithJSDoc": "export declare const revolution: (face: Face, center?: Point, direction?: Point, angle?: number) => Shape3D;",
      "usageCount": 1
    },
    {
      "name": "scale",
      "type": "function",
      "category": "Transformations",
      "signature": "export declare function scale(shape: TopoDS_Shape, center: Point, scale: number): TopoDS_Shape;",
      "signatureWithJSDoc": "export declare function scale(shape: TopoDS_Shape, center: Point, scale: number): TopoDS_Shape;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        },
        {
          "name": "center",
          "type": "Point",
          "optional": false
        },
        {
          "name": "scale",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "TopoDS_Shape",
      "usageCount": 1
    },
    {
      "name": "Shape",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Shape<Type extends TopoDS_Shape> extends WrappingObj<Type> {\n    constructor(ocShape: Type);\n    clone(): this;\n    get hashCode(): number;\n    get isNull(): boolean;\n    isSame(other: AnyShape): boolean;\n    isEqual(other: AnyShape): boolean;\n    simplify(): this;\n    translate(xDist: number, yDist: number, zDist: number): this;\n    translate(vector: Point): this;\n    translateX(distance: number): this;\n    translateY(distance: number): this;\n    translateZ(distance: number): this;\n    rotate(angle: number, position?: Point, direction?: Point): this;\n    mirror(inputPlane?: Plane | PlaneName | Point, origin?: Point): this;\n    scale(scale: number, center?: Point): this;\n    get edges(): Edge[];\n    get faces(): Face[];\n    get wires(): Wire[];\n    get boundingBox(): BoundingBox;\n    mesh({ tolerance, angularTolerance }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n    }): ShapeMesh;\n    meshEdges({ tolerance, angularTolerance }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n    }): {\n        lines: number[];\n        edgeGroups: {\n            start: number;\n            count: number;\n            edgeId: number;\n        }[];\n    };\n    blobSTEP(): Blob;\n    blobSTL({ tolerance, angularTolerance, binary, }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n        binary?: boolean | undefined;\n    }): Blob;\n}",
      "signatureWithJSDoc": "export declare class Shape<Type extends TopoDS_Shape> extends WrappingObj<Type> {\n    constructor(ocShape: Type);\n    clone(): this;\n    get hashCode(): number;\n    get isNull(): boolean;\n    isSame(other: AnyShape): boolean;\n    isEqual(other: AnyShape): boolean;\n    /**\n     * Simplifies the shape by removing unnecessary edges and faces\n     */\n    simplify(): this;\n    /**\n     * Translates the shape of an arbitrary vector\n     *\n     * @category Shape Transformations\n     */\n    translate(xDist: number, yDist: number, zDist: number): this;\n    translate(vector: Point): this;\n    /**\n     * Translates the shape on the X axis\n     *\n     * @category Shape Transformations\n     */\n    translateX(distance: number): this;\n    /**\n     * Translates the shape on the Y axis\n     *\n     * @category Shape Transformations\n     */\n    translateY(distance: number): this;\n    /**\n     * Translates the shape on the Z axis\n     *\n     * @category Shape Transformations\n     */\n    translateZ(distance: number): this;\n    /**\n     * Rotates the shape\n     *\n     * @category Shape Transformations\n     */\n    rotate(angle: number, position?: Point, direction?: Point): this;\n    /**\n     * Mirrors the shape through a plane\n     *\n     * @category Shape Transformations\n     */\n    mirror(inputPlane?: Plane | PlaneName | Point, origin?: Point): this;\n    /**\n     * Returns a scaled version of the shape\n     *\n     * @category Shape Transformations\n     */\n    scale(scale: number, center?: Point): this;\n    get edges(): Edge[];\n    get faces(): Face[];\n    get wires(): Wire[];\n    get boundingBox(): BoundingBox;\n    /**\n     * Exports the current shape as a set of triangle. These can be used by threejs\n     * for instance to represent the the shape\n     *\n     * @category Shape Export\n     */\n    mesh({ tolerance, angularTolerance }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n    }): ShapeMesh;\n    /**\n     * Exports the current shape as a set of lines. These can be used by threejs\n     * for instance to represent the edges of the shape\n     *\n     * @category Shape Export\n     */\n    meshEdges({ tolerance, angularTolerance }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n    }): {\n        lines: number[];\n        edgeGroups: {\n            start: number;\n            count: number;\n            edgeId: number;\n        }[];\n    };\n    /**\n     * Exports the current shape as a STEP file as a Blob\n     *\n     * @category Shape Export\n     */\n    blobSTEP(): Blob;\n    /**\n     * Exports the current shape as a STL file as a Blob\n     *\n     * In order to create a STL file, the shape needs to be meshed. The\n     * tolerances correspond to the values used to mesh the shape.\n     *\n     * @category Shape Export\n     */\n    blobSTL({ tolerance, angularTolerance, binary, }?: {\n        tolerance?: number | undefined;\n        angularTolerance?: number | undefined;\n        binary?: boolean | undefined;\n    }): Blob;\n}",
      "usageCount": 1
    },
    {
      "name": "Sketch",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Sketch implements SketchInterface {\n    wire: Wire;\n    constructor(wire: Wire, { defaultOrigin, defaultDirection, }?: {\n        defaultOrigin?: Point;\n        defaultDirection?: Point;\n    });\n    get baseFace(): Face | null | undefined;\n    set baseFace(newFace: Face | null | undefined);\n    delete(): void;\n    clone(): Sketch;\n    get defaultOrigin(): Vector;\n    set defaultOrigin(newOrigin: Point);\n    get defaultDirection(): Vector;\n    set defaultDirection(newDirection: Point);\n    face(): Face;\n    wires(): Wire;\n    faces(): Face;\n    revolve(revolutionAxis?: Point, { origin }?: {\n        origin?: Point;\n    }): Shape3D;\n    extrude(extrusionDistance: number, { extrusionDirection, extrusionProfile, twistAngle, origin, }?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    sweepSketch(sketchOnPlane: (plane: Plane, origin: Point) => this, sweepConfig?: GenericSweepConfig): Shape3D;\n    loftWith(otherSketches: this | this[], loftConfig?: LoftConfig, returnShell?: boolean): Shape3D;\n}",
      "signatureWithJSDoc": "/**\n * A line drawing to be acted upon. It defines directions to be acted upon by\n * definition (extrusion direction for instance).\n *\n * Note that all operations will delete the sketch\n *\n * @category Sketching\n */\nexport declare class Sketch implements SketchInterface {\n    wire: Wire;\n    constructor(wire: Wire, { defaultOrigin, defaultDirection, }?: {\n        defaultOrigin?: Point;\n        defaultDirection?: Point;\n    });\n    get baseFace(): Face | null | undefined;\n    set baseFace(newFace: Face | null | undefined);\n    delete(): void;\n    clone(): Sketch;\n    get defaultOrigin(): Vector;\n    set defaultOrigin(newOrigin: Point);\n    get defaultDirection(): Vector;\n    set defaultDirection(newDirection: Point);\n    /**\n     * Transforms the lines into a face. The lines should be closed.\n     */\n    face(): Face;\n    wires(): Wire;\n    faces(): Face;\n    /**\n     * Revolves the drawing on an axis (defined by its direction and an origin\n     * (defaults to the sketch origin)\n     */\n    revolve(revolutionAxis?: Point, { origin }?: {\n        origin?: Point;\n    }): Shape3D;\n    /** Extrudes the sketch to a certain distance.(along the default direction\n     * and origin of the sketch).\n     *\n     * You can define another extrusion direction or origin,\n     *\n     * It is also possible to twist extrude with an angle (in degrees), or to\n     * give a profile to the extrusion (the endFactor will scale the face, and\n     * the profile will define how the scale is applied (either linarly or with\n     * a s-shape).\n     */\n    extrude(extrusionDistance: number, { extrusionDirection, extrusionProfile, twistAngle, origin, }?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    /**\n     * Sweep along this sketch another sketch defined in the function\n     * `sketchOnPlane`.\n     *\n     * TODO: clean the interface of the sweep config to make it more\n     * understandable.\n     */\n    sweepSketch(sketchOnPlane: (plane: Plane, origin: Point) => this, sweepConfig?: GenericSweepConfig): Shape3D;\n    /** Loft between this sketch and another sketch (or an array of them)\n     *\n     * You can also define a `startPoint` for the loft (that will be placed\n     * before this sketch) and an `endPoint` after the last one.\n     *\n     * You can also define if you want the loft to result in a ruled surface.\n     *\n     * Note that all sketches will be deleted by this operation\n     */\n    loftWith(otherSketches: this | this[], loftConfig?: LoftConfig, returnShell?: boolean): Shape3D;\n}",
      "usageCount": 1,
      "jsDoc": "Sketching"
    },
    {
      "name": "_1DShape",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare abstract class _1DShape<Type extends TopoDS_Shape> extends Shape<Type> {\n    get repr(): string;\n    get curve(): Curve;\n    get startPoint(): Vector;\n    get endPoint(): Vector;\n    tangentAt(position?: number): Vector;\n    pointAt(position?: number): Vector;\n    get isClosed(): boolean;\n    get isPeriodic(): boolean;\n    get period(): number;\n    get geomType(): CurveType;\n    get length(): number;\n    get orientation(): \"forward\" | \"backward\";\n}",
      "signatureWithJSDoc": "export declare abstract class _1DShape<Type extends TopoDS_Shape> extends Shape<Type> {\n    get repr(): string;\n    get curve(): Curve;\n    get startPoint(): Vector;\n    get endPoint(): Vector;\n    tangentAt(position?: number): Vector;\n    pointAt(position?: number): Vector;\n    get isClosed(): boolean;\n    get isPeriodic(): boolean;\n    get period(): number;\n    get geomType(): CurveType;\n    get length(): number;\n    get orientation(): \"forward\" | \"backward\";\n}",
      "usageCount": 0
    },
    {
      "name": "_3DShape",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class _3DShape<Type extends TopoDS_Shape> extends Shape<Type> {\n    fuse(other: Shape3D, { optimisation, }?: {\n        optimisation?: \"none\" | \"commonFace\" | \"sameFace\";\n    }): Shape3D;\n    cut(tool: Shape3D, { optimisation, }?: {\n        optimisation?: \"none\" | \"commonFace\" | \"sameFace\";\n    }): Shape3D;\n    intersect(tool: AnyShape): AnyShape;\n    shell(config: {\n        filter: FaceFinder;\n        thickness: number;\n    }, tolerance?: number): Shape3D;\n    shell(thickness: number, finderFcn: (f: FaceFinder) => FaceFinder, tolerance?: number): Shape3D;\n    fillet(radiusConfig: RadiusConfig, filter?: (e: EdgeFinder) => EdgeFinder): Shape3D;\n    chamfer(radiusConfig: RadiusConfig, filter?: (e: EdgeFinder) => EdgeFinder): Shape3D;\n}",
      "signatureWithJSDoc": "export declare class _3DShape<Type extends TopoDS_Shape> extends Shape<Type> {\n    /**\n     * Builds a new shape out of the two, fused, shapes\n     *\n     * @category Shape Modifications\n     */\n    fuse(other: Shape3D, { optimisation, }?: {\n        optimisation?: \"none\" | \"commonFace\" | \"sameFace\";\n    }): Shape3D;\n    /**\n     * Builds a new shape by removing the tool tape from this shape\n     *\n     * @category Shape Modifications\n     */\n    cut(tool: Shape3D, { optimisation, }?: {\n        optimisation?: \"none\" | \"commonFace\" | \"sameFace\";\n    }): Shape3D;\n    /**\n     * Builds a new shape by intersecting this shape and another\n     *\n     * @category Shape Modifications\n     */\n    intersect(tool: AnyShape): AnyShape;\n    /**\n     * Hollows out the current shape, removing the faces found by the `filter` and\n     * keeping a border of `thickness`\n     *\n     * @category Shape Modifications\n     */\n    shell(config: {\n        filter: FaceFinder;\n        thickness: number;\n    }, tolerance?: number): Shape3D;\n    shell(thickness: number, finderFcn: (f: FaceFinder) => FaceFinder, tolerance?: number): Shape3D;\n    /**\n     * Creates a new shapes with some edges filletted, as specified in the\n     * radius config.\n     *\n     * If the radius is a filter finder object (with an EdgeFinder as filter,\n     * and a radius to specifiy the fillet radius), the fillet will only be\n     * applied to the edges as selected by the finder. The finder will be\n     * deleted unless it is explicitly specified to `keep` it.\n     *\n     * If the radius is a number all the edges will be filletted.\n     *\n     * If the radius is a function edges will be filletted according to the\n     * value returned by the function (0 or null will not add any fillet).\n     *\n     * @category Shape Modifications\n     */\n    fillet(radiusConfig: RadiusConfig, filter?: (e: EdgeFinder) => EdgeFinder): Shape3D;\n    /**\n     * Creates a new shapes with some edges chamfered, as specified in the\n     * radius config.\n     *\n     * If the radius is a filter finder object (with an EdgeFinder as filter,\n     * and a radius to specifiy the chamfer radius), the fillet will only be\n     * applied to the edges as selected by the finder. The finder will be\n     * deleted unless it is explicitly specified to `keep` it.\n     *\n     * If the radius is a number all the edges will be chamfered.\n     *\n     * If the radius is a function edges will be chamfered according to the\n     * value returned by the function (0 or null will not add any chamfer).\n     *\n     * @category Shape Modifications\n     */\n    chamfer(radiusConfig: RadiusConfig, filter?: (e: EdgeFinder) => EdgeFinder): Shape3D;\n}",
      "usageCount": 0
    },
    {
      "name": "addHolesInFace",
      "type": "constant",
      "category": "Finders & Filters",
      "signature": "export declare const addHolesInFace: (face: Face, holes: Wire[]) => Face;",
      "signatureWithJSDoc": "export declare const addHolesInFace: (face: Face, holes: Wire[]) => Face;",
      "usageCount": 0
    },
    {
      "name": "AnyShape",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type AnyShape = Vertex | Edge | Wire | Face | Shell | Solid | CompSolid | Compound;",
      "signatureWithJSDoc": "export declare type AnyShape = Vertex | Edge | Wire | Face | Shell | Solid | CompSolid | Compound;",
      "usageCount": 0
    },
    {
      "name": "ApproximationOptions",
      "type": "interface",
      "category": "Utilities",
      "signature": "declare interface ApproximationOptions {\n    tolerance?: number;\n    continuity?: \"C0\" | \"C1\" | \"C2\" | \"C3\";\n    maxSegments?: number;\n}",
      "signatureWithJSDoc": "declare interface ApproximationOptions {\n    tolerance?: number;\n    continuity?: \"C0\" | \"C1\" | \"C2\" | \"C3\";\n    maxSegments?: number;\n}",
      "usageCount": 0
    },
    {
      "name": "asDir",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function asDir(coords: Point): gp_Dir;",
      "signatureWithJSDoc": "export declare function asDir(coords: Point): gp_Dir;",
      "parameters": [
        {
          "name": "coords",
          "type": "Point",
          "optional": false
        }
      ],
      "returnType": "gp_Dir",
      "usageCount": 0
    },
    {
      "name": "asPnt",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function asPnt(coords: Point): gp_Pnt;",
      "signatureWithJSDoc": "export declare function asPnt(coords: Point): gp_Pnt;",
      "parameters": [
        {
          "name": "coords",
          "type": "Point",
          "optional": false
        }
      ],
      "returnType": "gp_Pnt",
      "usageCount": 0
    },
    {
      "name": "AssemblyExporter",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class AssemblyExporter extends WrappingObj<TDocStd_Document> {\n}",
      "signatureWithJSDoc": "export declare class AssemblyExporter extends WrappingObj<TDocStd_Document> {\n}",
      "usageCount": 0
    },
    {
      "name": "axis2d",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const axis2d: (point: Point2D, direction: Point2D) => gp_Ax2d;",
      "signatureWithJSDoc": "export declare const axis2d: (point: Point2D, direction: Point2D) => gp_Ax2d;",
      "usageCount": 0
    },
    {
      "name": "BaseSketcher2d",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class BaseSketcher2d {\n    constructor(origin?: Point2D);\n    movePointerTo(point: Point2D): this;\n    lineTo(point: Point2D): this;\n    line(xDist: number, yDist: number): this;\n    vLine(distance: number): this;\n    hLine(distance: number): this;\n    vLineTo(yPos: number): this;\n    hLineTo(xPos: number): this;\n    polarLineTo([r, theta]: Point2D): this;\n    polarLine(distance: number, angle: number): this;\n    tangentLine(distance: number): this;\n    threePointsArcTo(end: Point2D, midPoint: Point2D): this;\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    vSagittaArc(distance: number, sagitta: number): this;\n    hSagittaArc(distance: number, sagitta: number): this;\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    vBulgeArc(distance: number, bulge: number): this;\n    hBulgeArc(distance: number, bulge: number): this;\n    tangentArcTo(end: Point2D): this;\n    tangentArc(xDist: number, yDist: number): this;\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    halfEllipseTo(end: Point2D, minorRadius: number, sweep?: boolean): this;\n    halfEllipse(xDist: number, yDist: number, minorRadius: number, sweep?: boolean): this;\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    smoothSpline(xDist: number, yDist: number, splineConfig?: SplineConfig): this;\n    customCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): this;\n}",
      "signatureWithJSDoc": "export declare class BaseSketcher2d {\n    constructor(origin?: Point2D);\n    movePointerTo(point: Point2D): this;\n    lineTo(point: Point2D): this;\n    line(xDist: number, yDist: number): this;\n    vLine(distance: number): this;\n    hLine(distance: number): this;\n    vLineTo(yPos: number): this;\n    hLineTo(xPos: number): this;\n    polarLineTo([r, theta]: Point2D): this;\n    polarLine(distance: number, angle: number): this;\n    tangentLine(distance: number): this;\n    threePointsArcTo(end: Point2D, midPoint: Point2D): this;\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    vSagittaArc(distance: number, sagitta: number): this;\n    hSagittaArc(distance: number, sagitta: number): this;\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    vBulgeArc(distance: number, bulge: number): this;\n    hBulgeArc(distance: number, bulge: number): this;\n    tangentArcTo(end: Point2D): this;\n    tangentArc(xDist: number, yDist: number): this;\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation?: number, longAxis?: boolean, sweep?: boolean): this;\n    halfEllipseTo(end: Point2D, minorRadius: number, sweep?: boolean): this;\n    halfEllipse(xDist: number, yDist: number, minorRadius: number, sweep?: boolean): this;\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    smoothSpline(xDist: number, yDist: number, splineConfig?: SplineConfig): this;\n    /**\n     * Changes the corner between the previous and next segments.\n     */\n    customCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): this;\n}",
      "usageCount": 0
    },
    {
      "name": "basicFaceExtrusion",
      "type": "constant",
      "category": "3D Operations",
      "signature": "export declare const basicFaceExtrusion: (face: Face, extrusionVec: Vector) => Solid;",
      "signatureWithJSDoc": "export declare const basicFaceExtrusion: (face: Face, extrusionVec: Vector) => Solid;",
      "usageCount": 0
    },
    {
      "name": "Blueprint",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class Blueprint implements DrawingInterface {\n    curves: Curve2D[];\n    constructor(curves: Curve2D[]);\n    delete(): void;\n    clone(): Blueprint;\n    get repr(): string;\n    get boundingBox(): BoundingBox2d;\n    get orientation(): \"clockwise\" | \"counterClockwise\";\n    stretch(ratio: number, direction: Point2D, origin?: Point2D): Blueprint;\n    scale(scaleFactor: number, center?: Point2D): Blueprint;\n    rotate(angle: number, center?: Point2D): Blueprint;\n    translate(xDist: number, yDist: number): Blueprint;\n    translate(translationVector: Point2D): Blueprint;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Blueprint;\n    sketchOnPlane(inputPlane?: PlaneName | Plane, origin?: Point | number): Sketch;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): Sketch;\n    toSVGPathD(): string;\n    toSVGPath(): string;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[];\n    toSVG(margin?: number): string;\n    get firstPoint(): Point2D;\n    get lastPoint(): Point2D;\n    isInside(point: Point2D): boolean;\n    isClosed(): boolean;\n    intersects(other: Blueprint): boolean;\n}",
      "signatureWithJSDoc": "/**\n * A Blueprint is an abstract Sketch, a 2D set of curves that can then be\n * sketched on different surfaces (faces or planes)\n *\n * You should create them by \"sketching\" with a `BlueprintSketcher`\n */\nexport declare class Blueprint implements DrawingInterface {\n    curves: Curve2D[];\n    constructor(curves: Curve2D[]);\n    delete(): void;\n    clone(): Blueprint;\n    get repr(): string;\n    get boundingBox(): BoundingBox2d;\n    get orientation(): \"clockwise\" | \"counterClockwise\";\n    stretch(ratio: number, direction: Point2D, origin?: Point2D): Blueprint;\n    scale(scaleFactor: number, center?: Point2D): Blueprint;\n    rotate(angle: number, center?: Point2D): Blueprint;\n    translate(xDist: number, yDist: number): Blueprint;\n    translate(translationVector: Point2D): Blueprint;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Blueprint;\n    sketchOnPlane(inputPlane?: PlaneName | Plane, origin?: Point | number): Sketch;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): Sketch;\n    toSVGPathD(): string;\n    toSVGPath(): string;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[];\n    toSVG(margin?: number): string;\n    get firstPoint(): Point2D;\n    get lastPoint(): Point2D;\n    isInside(point: Point2D): boolean;\n    isClosed(): boolean;\n    intersects(other: Blueprint): boolean;\n}",
      "usageCount": 0
    },
    {
      "name": "Blueprints",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class Blueprints implements DrawingInterface {\n    blueprints: Array<Blueprint | CompoundBlueprint>;\n    constructor(blueprints: Array<Blueprint | CompoundBlueprint>);\n    get repr(): string;\n    clone(): Blueprints;\n    get boundingBox(): BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): Blueprints;\n    rotate(angle: number, center?: Point2D): Blueprints;\n    scale(scaleFactor: number, center?: Point2D): Blueprints;\n    translate(xDist: number, yDist: number): Blueprints;\n    translate(translationVector: Point2D): Blueprints;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Blueprints;\n    sketchOnPlane(plane?: PlaneName | Plane, origin?: Point | number): Sketches;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): Sketches;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[][];\n    toSVG(margin?: number): string;\n}",
      "signatureWithJSDoc": "export declare class Blueprints implements DrawingInterface {\n    blueprints: Array<Blueprint | CompoundBlueprint>;\n    constructor(blueprints: Array<Blueprint | CompoundBlueprint>);\n    get repr(): string;\n    clone(): Blueprints;\n    get boundingBox(): BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): Blueprints;\n    rotate(angle: number, center?: Point2D): Blueprints;\n    scale(scaleFactor: number, center?: Point2D): Blueprints;\n    translate(xDist: number, yDist: number): Blueprints;\n    translate(translationVector: Point2D): Blueprints;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Blueprints;\n    sketchOnPlane(plane?: PlaneName | Plane, origin?: Point | number): Sketches;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): Sketches;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[][];\n    toSVG(margin?: number): string;\n}",
      "usageCount": 0
    },
    {
      "name": "BlueprintSketcher",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class BlueprintSketcher extends BaseSketcher2d implements GenericSketcher<Blueprint> {\n    constructor(origin?: Point2D);\n    done(): Blueprint;\n    close(): Blueprint;\n    closeWithMirror(): Blueprint;\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Blueprint;\n}",
      "signatureWithJSDoc": "export declare class BlueprintSketcher extends BaseSketcher2d implements GenericSketcher<Blueprint> {\n    constructor(origin?: Point2D);\n    done(): Blueprint;\n    close(): Blueprint;\n    closeWithMirror(): Blueprint;\n    /**\n     * Stop drawing, make sure the sketch is closed (by adding a straight line to\n     * from the last point to the first), add a fillet between the last and the\n     * first segments and returns the sketch.\n     */\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Blueprint;\n}",
      "usageCount": 0
    },
    {
      "name": "BoundingBox",
      "type": "class",
      "category": "Primitives & Makers",
      "signature": "export declare class BoundingBox extends WrappingObj<Bnd_Box> {\n    constructor(wrapped?: Bnd_Box);\n    get repr(): string;\n    get bounds(): [\n        SimplePoint,\n        SimplePoint\n    ];\n    get center(): SimplePoint;\n    get width(): number;\n    get height(): number;\n    get depth(): number;\n    add(other: BoundingBox): void;\n    isOut(other: BoundingBox): boolean;\n}",
      "signatureWithJSDoc": "export declare class BoundingBox extends WrappingObj<Bnd_Box> {\n    constructor(wrapped?: Bnd_Box);\n    get repr(): string;\n    get bounds(): [\n        SimplePoint,\n        SimplePoint\n    ];\n    get center(): SimplePoint;\n    get width(): number;\n    get height(): number;\n    get depth(): number;\n    add(other: BoundingBox): void;\n    isOut(other: BoundingBox): boolean;\n}",
      "usageCount": 0
    },
    {
      "name": "BoundingBox2d",
      "type": "class",
      "category": "Primitives & Makers",
      "signature": "export declare class BoundingBox2d extends WrappingObj<Bnd_Box2d> {\n    constructor(wrapped?: Bnd_Box2d);\n    get repr(): string;\n    get bounds(): [\n        Point2D,\n        Point2D\n    ];\n    get center(): Point2D;\n    get width(): number;\n    get height(): number;\n    outsidePoint(paddingPercent?: number): Point2D;\n    add(other: BoundingBox2d): void;\n    isOut(other: BoundingBox2d): boolean;\n    containsPoint(other: Point2D): boolean;\n}",
      "signatureWithJSDoc": "export declare class BoundingBox2d extends WrappingObj<Bnd_Box2d> {\n    constructor(wrapped?: Bnd_Box2d);\n    get repr(): string;\n    get bounds(): [\n        Point2D,\n        Point2D\n    ];\n    get center(): Point2D;\n    get width(): number;\n    get height(): number;\n    outsidePoint(paddingPercent?: number): Point2D;\n    add(other: BoundingBox2d): void;\n    isOut(other: BoundingBox2d): boolean;\n    containsPoint(other: Point2D): boolean;\n}",
      "usageCount": 0
    },
    {
      "name": "BSplineApproximationConfig",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface BSplineApproximationConfig {\n    tolerance?: number;\n    degMax?: number;\n    degMin?: number;\n    smoothing?: null | [\n        number,\n        number,\n        number\n    ];\n}",
      "signatureWithJSDoc": "export declare interface BSplineApproximationConfig {\n    tolerance?: number;\n    degMax?: number;\n    degMin?: number;\n    smoothing?: null | [\n        number,\n        number,\n        number\n    ];\n}",
      "usageCount": 0
    },
    {
      "name": "cast",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function cast(shape: TopoDS_Shape): AnyShape;",
      "signatureWithJSDoc": "export declare function cast(shape: TopoDS_Shape): AnyShape;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        }
      ],
      "returnType": "AnyShape",
      "usageCount": 0
    },
    {
      "name": "combineFinderFilters",
      "type": "constant",
      "category": "Finders & Filters",
      "signature": "export declare const combineFinderFilters: <Type, T>(filters: {\n    filter: Finder<Type, T>;\n    radius: number;\n}[]) => [\n    (v: Type) => number,\n    () => void\n];",
      "signatureWithJSDoc": "/**\n * Combine a set of finder filters (defined with radius) to pass as a filter\n * function.\n *\n * It returns the filter, as well as a cleanup function.\n */\nexport declare const combineFinderFilters: <Type, T>(filters: {\n    filter: Finder<Type, T>;\n    radius: number;\n}[]) => [\n    (v: Type) => number,\n    () => void\n];",
      "usageCount": 0
    },
    {
      "name": "complexExtrude",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function complexExtrude(wire: Wire, center: Point, normal: Point, profileShape: ExtrusionProfile | undefined, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "signatureWithJSDoc": "export declare function complexExtrude(wire: Wire, center: Point, normal: Point, profileShape: ExtrusionProfile | undefined, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "center",
          "type": "Point",
          "optional": false
        },
        {
          "name": "normal",
          "type": "Point",
          "optional": false
        },
        {
          "name": "profileShape",
          "type": "ExtrusionProfile | undefined",
          "optional": false
        },
        {
          "name": "shellMode",
          "type": "true",
          "optional": false
        }
      ],
      "returnType": "[Shape3D, Wire, Wire]",
      "usageCount": 0
    },
    {
      "name": "complexExtrude",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function complexExtrude(wire: Wire, center: Point, normal: Point, profileShape?: ExtrusionProfile, shellMode?: false): Shape3D;",
      "signatureWithJSDoc": "export declare function complexExtrude(wire: Wire, center: Point, normal: Point, profileShape?: ExtrusionProfile, shellMode?: false): Shape3D;",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "center",
          "type": "Point",
          "optional": false
        },
        {
          "name": "normal",
          "type": "Point",
          "optional": false
        },
        {
          "name": "profileShape",
          "type": "ExtrusionProfile",
          "optional": true
        },
        {
          "name": "shellMode",
          "type": "false",
          "optional": true
        }
      ],
      "returnType": "Shape3D",
      "usageCount": 0
    },
    {
      "name": "Compound",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Compound extends _3DShape<TopoDS_Compound> {\n}",
      "signatureWithJSDoc": "export declare class Compound extends _3DShape<TopoDS_Compound> {\n}",
      "usageCount": 0
    },
    {
      "name": "CompoundBlueprint",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class CompoundBlueprint implements DrawingInterface {\n    blueprints: Blueprint[];\n    constructor(blueprints: Blueprint[]);\n    clone(): CompoundBlueprint;\n    get boundingBox(): BoundingBox2d;\n    get repr(): string;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): CompoundBlueprint;\n    rotate(angle: number, center?: Point2D): CompoundBlueprint;\n    scale(scaleFactor: number, center?: Point2D): CompoundBlueprint;\n    translate(xDist: number, yDist: number): CompoundBlueprint;\n    translate(translationVector: Point2D): CompoundBlueprint;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): CompoundBlueprint;\n    sketchOnPlane(plane?: PlaneName | Plane, origin?: Point | number): CompoundSketch;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): CompoundSketch;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[];\n    toSVGGroup(): string;\n    toSVG(margin?: number): string;\n}",
      "signatureWithJSDoc": "export declare class CompoundBlueprint implements DrawingInterface {\n    blueprints: Blueprint[];\n    constructor(blueprints: Blueprint[]);\n    clone(): CompoundBlueprint;\n    get boundingBox(): BoundingBox2d;\n    get repr(): string;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): CompoundBlueprint;\n    rotate(angle: number, center?: Point2D): CompoundBlueprint;\n    scale(scaleFactor: number, center?: Point2D): CompoundBlueprint;\n    translate(xDist: number, yDist: number): CompoundBlueprint;\n    translate(translationVector: Point2D): CompoundBlueprint;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): CompoundBlueprint;\n    sketchOnPlane(plane?: PlaneName | Plane, origin?: Point | number): CompoundSketch;\n    sketchOnFace(face: Face, scaleMode?: ScaleMode): CompoundSketch;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[];\n    toSVGGroup(): string;\n    toSVG(margin?: number): string;\n}",
      "usageCount": 0
    },
    {
      "name": "compoundShapes",
      "type": "constant",
      "category": "Geometry Types",
      "signature": "export declare const compoundShapes: (shapeArray: AnyShape[]) => AnyShape;",
      "signatureWithJSDoc": "export declare const compoundShapes: (shapeArray: AnyShape[]) => AnyShape;",
      "usageCount": 0
    },
    {
      "name": "CompoundSketch",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class CompoundSketch implements SketchInterface {\n    sketches: Sketch[];\n    constructor(sketches: Sketch[]);\n    delete(): void;\n    get outerSketch(): Sketch;\n    get innerSketches(): Sketch[];\n    get wires(): AnyShape;\n    face(): Face;\n    extrude(extrusionDistance: number, { extrusionDirection, extrusionProfile, twistAngle, origin, }?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    revolve(revolutionAxis?: Point, { origin }?: {\n        origin?: Point;\n    }): Shape3D;\n    loftWith(otherCompound: this, loftConfig: LoftConfig): Shape3D;\n}",
      "signatureWithJSDoc": "/**\n * A group of sketches that should correspond to a unique face (i.e. an outer\n * sketch, and multiple holes within this sketch.\n *\n * All the sketches should share the same base face (or surface)\n *\n * Ideally generated from a `CompoundBlueprint`\n */\nexport declare class CompoundSketch implements SketchInterface {\n    sketches: Sketch[];\n    constructor(sketches: Sketch[]);\n    delete(): void;\n    get outerSketch(): Sketch;\n    get innerSketches(): Sketch[];\n    get wires(): AnyShape;\n    face(): Face;\n    extrude(extrusionDistance: number, { extrusionDirection, extrusionProfile, twistAngle, origin, }?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    /**\n     * Revolves the drawing on an axis (defined by its direction and an origin\n     * (defaults to the sketch origin)\n     */\n    revolve(revolutionAxis?: Point, { origin }?: {\n        origin?: Point;\n    }): Shape3D;\n    loftWith(otherCompound: this, loftConfig: LoftConfig): Shape3D;\n}",
      "usageCount": 0
    },
    {
      "name": "CompSolid",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class CompSolid extends _3DShape<TopoDS_CompSolid> {\n}",
      "signatureWithJSDoc": "export declare class CompSolid extends _3DShape<TopoDS_CompSolid> {\n}",
      "usageCount": 0
    },
    {
      "name": "CoordSystem",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type CoordSystem = \"reference\" | {\n    origin: Point;\n    zDir: Point;\n    xDir: Point;\n};",
      "signatureWithJSDoc": "declare type CoordSystem = \"reference\" | {\n    origin: Point;\n    zDir: Point;\n    xDir: Point;\n};",
      "usageCount": 0
    },
    {
      "name": "Corner",
      "type": "type",
      "category": "Finders & Filters",
      "signature": "export declare type Corner = {\n    firstCurve: Curve2D;\n    secondCurve: Curve2D;\n    point: Point2D;\n};",
      "signatureWithJSDoc": "export declare type Corner = {\n    firstCurve: Curve2D;\n    secondCurve: Curve2D;\n    point: Point2D;\n};",
      "usageCount": 0
    },
    {
      "name": "CornerFinder",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class CornerFinder extends Finder<Corner, Blueprint> {\n    clone(): CornerFinder;\n    inList(elementList: Point2D[]): this;\n    atDistance(distance: number, point?: Point2D): this;\n    atPoint(point: Point2D): this;\n    inBox(corner1: Point2D, corner2: Point2D): this;\n    ofAngle(angle: number): this;\n    shouldKeep(element: Corner): boolean;\n}",
      "signatureWithJSDoc": "export declare class CornerFinder extends Finder<Corner, Blueprint> {\n    clone(): CornerFinder;\n    /**\n     * Filter to find corner that have their point are in the list.\n     *\n     * @category Filter\n     */\n    inList(elementList: Point2D[]): this;\n    /**\n     * Filter to find elements that are at a specified distance from a point.\n     *\n     * @category Filter\n     */\n    atDistance(distance: number, point?: Point2D): this;\n    /**\n     * Filter to find elements that contain a certain point\n     *\n     * @category Filter\n     */\n    atPoint(point: Point2D): this;\n    /**\n     * Filter to find elements that are within a box\n     *\n     * @category Filter\n     */\n    inBox(corner1: Point2D, corner2: Point2D): this;\n    /**\n     * Filter to find corner that a certain angle between them - only between\n     * 0 and 180.\n     *\n     * @category Filter\n     */\n    ofAngle(angle: number): this;\n    shouldKeep(element: Corner): boolean;\n}",
      "usageCount": 0
    },
    {
      "name": "createAssembly",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function createAssembly(shapes?: ShapeConfig[]): AssemblyExporter;",
      "signatureWithJSDoc": "export declare function createAssembly(shapes?: ShapeConfig[]): AssemblyExporter;",
      "parameters": [
        {
          "name": "shapes",
          "type": "ShapeConfig[]",
          "optional": true
        }
      ],
      "returnType": "AssemblyExporter",
      "usageCount": 0
    },
    {
      "name": "createNamedPlane",
      "type": "constant",
      "category": "Geometry Types",
      "signature": "export declare const createNamedPlane: (plane: PlaneName, sourceOrigin?: Point | number) => Plane;",
      "signatureWithJSDoc": "export declare const createNamedPlane: (plane: PlaneName, sourceOrigin?: Point | number) => Plane;",
      "usageCount": 0
    },
    {
      "name": "CubeFace",
      "type": "type",
      "category": "Finders & Filters",
      "signature": "export declare type CubeFace = \"front\" | \"back\" | \"top\" | \"bottom\" | \"left\" | \"right\";",
      "signatureWithJSDoc": "export declare type CubeFace = \"front\" | \"back\" | \"top\" | \"bottom\" | \"left\" | \"right\";",
      "usageCount": 0
    },
    {
      "name": "Curve",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Curve extends WrappingObj<CurveLike> {\n    get repr(): string;\n    get curveType(): CurveType;\n    get startPoint(): Vector;\n    get endPoint(): Vector;\n    pointAt(position?: number): Vector;\n    tangentAt(position?: number): Vector;\n    get isClosed(): boolean;\n    get isPeriodic(): boolean;\n    get period(): number;\n}",
      "signatureWithJSDoc": "export declare class Curve extends WrappingObj<CurveLike> {\n    get repr(): string;\n    get curveType(): CurveType;\n    get startPoint(): Vector;\n    get endPoint(): Vector;\n    pointAt(position?: number): Vector;\n    tangentAt(position?: number): Vector;\n    get isClosed(): boolean;\n    get isPeriodic(): boolean;\n    get period(): number;\n}",
      "usageCount": 0
    },
    {
      "name": "Curve2D",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Curve2D extends WrappingObj<Handle_Geom2d_Curve> {\n    constructor(handle: Handle_Geom2d_Curve);\n    get boundingBox(): BoundingBox2d;\n    get repr(): string;\n    get innerCurve(): Geom2d_Curve;\n    value(parameter: number): Point2D;\n    get firstPoint(): Point2D;\n    get lastPoint(): Point2D;\n    get firstParameter(): number;\n    get lastParameter(): number;\n    adaptor(): Geom2dAdaptor_Curve;\n    get geomType(): CurveType;\n    clone(): Curve2D;\n    reverse(): void;\n    distanceFrom(element: Curve2D | Point2D): number;\n    isOnCurve(point: Point2D): boolean;\n    parameter(point: Point2D, precision?: number): number;\n    tangentAt(index: number | Point2D): Point2D;\n    splitAt(points: Point2D[] | number[], precision?: number): Curve2D[];\n}",
      "signatureWithJSDoc": "export declare class Curve2D extends WrappingObj<Handle_Geom2d_Curve> {\n    constructor(handle: Handle_Geom2d_Curve);\n    get boundingBox(): BoundingBox2d;\n    get repr(): string;\n    get innerCurve(): Geom2d_Curve;\n    value(parameter: number): Point2D;\n    get firstPoint(): Point2D;\n    get lastPoint(): Point2D;\n    get firstParameter(): number;\n    get lastParameter(): number;\n    adaptor(): Geom2dAdaptor_Curve;\n    get geomType(): CurveType;\n    clone(): Curve2D;\n    reverse(): void;\n    distanceFrom(element: Curve2D | Point2D): number;\n    isOnCurve(point: Point2D): boolean;\n    parameter(point: Point2D, precision?: number): number;\n    tangentAt(index: number | Point2D): Point2D;\n    splitAt(points: Point2D[] | number[], precision?: number): Curve2D[];\n}",
      "usageCount": 0
    },
    {
      "name": "CurveLike",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface CurveLike {\n    delete(): void;\n    Value(v: number): gp_Pnt;\n    IsPeriodic(): boolean;\n    Period(): number;\n    IsClosed(): boolean;\n    FirstParameter(): number;\n    LastParameter(): number;\n    GetType?(): any;\n    D1(v: number, p: gp_Pnt, vPrime: gp_Vec): void;\n}",
      "signatureWithJSDoc": "export declare interface CurveLike {\n    delete(): void;\n    Value(v: number): gp_Pnt;\n    IsPeriodic(): boolean;\n    Period(): number;\n    IsClosed(): boolean;\n    FirstParameter(): number;\n    LastParameter(): number;\n    GetType?(): any;\n    D1(v: number, p: gp_Pnt, vPrime: gp_Vec): void;\n}",
      "usageCount": 0
    },
    {
      "name": "CurveType",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type CurveType = \"LINE\" | \"CIRCLE\" | \"ELLIPSE\" | \"HYPERBOLA\" | \"PARABOLA\" | \"BEZIER_CURVE\" | \"BSPLINE_CURVE\" | \"OFFSET_CURVE\" | \"OTHER_CURVE\";",
      "signatureWithJSDoc": "export declare type CurveType = \"LINE\" | \"CIRCLE\" | \"ELLIPSE\" | \"HYPERBOLA\" | \"PARABOLA\" | \"BEZIER_CURVE\" | \"BSPLINE_CURVE\" | \"OFFSET_CURVE\" | \"OTHER_CURVE\";",
      "usageCount": 0
    },
    {
      "name": "cut2D",
      "type": "constant",
      "category": "Modifications",
      "signature": "export declare const cut2D: (first: Shape2D, second: Shape2D) => Blueprint | Blueprints | CompoundBlueprint | null;",
      "signatureWithJSDoc": "export declare const cut2D: (first: Shape2D, second: Shape2D) => Blueprint | Blueprints | CompoundBlueprint | null;",
      "usageCount": 0
    },
    {
      "name": "cutBlueprints",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const cutBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "signatureWithJSDoc": "export declare const cutBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "usageCount": 0
    },
    {
      "name": "DEG2RAD",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const DEG2RAD: number;",
      "signatureWithJSDoc": "export declare const DEG2RAD: number;",
      "usageCount": 0
    },
    {
      "name": "Deletable",
      "type": "interface",
      "category": "Utilities",
      "signature": "declare interface Deletable {\n    delete: () => void;\n}",
      "signatureWithJSDoc": "declare interface Deletable {\n    delete: () => void;\n}",
      "usageCount": 0
    },
    {
      "name": "Direction",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type Direction = Point | \"X\" | \"Y\" | \"Z\";",
      "signatureWithJSDoc": "declare type Direction = Point | \"X\" | \"Y\" | \"Z\";",
      "usageCount": 0
    },
    {
      "name": "Direction_2",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type Direction_2 = \"X\" | \"Y\" | \"Z\";",
      "signatureWithJSDoc": "declare type Direction_2 = \"X\" | \"Y\" | \"Z\";",
      "usageCount": 0
    },
    {
      "name": "DistanceQuery",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class DistanceQuery extends WrappingObj<BRepExtrema_DistShapeShape> {\n    constructor(shape: AnyShape);\n    distanceTo(shape: AnyShape): number;\n}",
      "signatureWithJSDoc": "export declare class DistanceQuery extends WrappingObj<BRepExtrema_DistShapeShape> {\n    constructor(shape: AnyShape);\n    distanceTo(shape: AnyShape): number;\n}",
      "usageCount": 0
    },
    {
      "name": "DistanceTool",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class DistanceTool extends WrappingObj<BRepExtrema_DistShapeShape> {\n    constructor();\n    distanceBetween(shape1: AnyShape, shape2: AnyShape): number;\n}",
      "signatureWithJSDoc": "export declare class DistanceTool extends WrappingObj<BRepExtrema_DistShapeShape> {\n    constructor();\n    distanceBetween(shape1: AnyShape, shape2: AnyShape): number;\n}",
      "usageCount": 0
    },
    {
      "name": "downcast",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function downcast(shape: TopoDS_Shape): GenericTopo;",
      "signatureWithJSDoc": "export declare function downcast(shape: TopoDS_Shape): GenericTopo;",
      "parameters": [
        {
          "name": "shape",
          "type": "TopoDS_Shape",
          "optional": false
        }
      ],
      "returnType": "GenericTopo",
      "usageCount": 0
    },
    {
      "name": "drawEllipse",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawEllipse(majorRadius: number, minorRadius: number): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of an ellipse.\n *\n * The ellipse is centered on [0, 0], with axes aligned with the coordinates.\n *\n * @category Drawing\n */\nexport declare function drawEllipse(majorRadius: number, minorRadius: number): Drawing;",
      "parameters": [
        {
          "name": "majorRadius",
          "type": "number",
          "optional": false
        },
        {
          "name": "minorRadius",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Drawing",
      "usageCount": 0,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawFaceOutline",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawFaceOutline(face: Face): Drawing;",
      "signatureWithJSDoc": "export declare function drawFaceOutline(face: Face): Drawing;",
      "parameters": [
        {
          "name": "face",
          "type": "Face",
          "optional": false
        }
      ],
      "returnType": "Drawing",
      "usageCount": 0
    },
    {
      "name": "Drawing",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class Drawing implements DrawingInterface {\n    constructor(innerShape?: Shape2D);\n    clone(): Drawing;\n    get boundingBox(): BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): Drawing;\n    get repr(): string;\n    rotate(angle: number, center?: Point2D): Drawing;\n    translate(xDist: number, yDist: number): Drawing;\n    translate(translationVector: Point2D): Drawing;\n    scale(scaleFactor: number, center?: Point2D): Drawing;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Drawing;\n    cut(other: Drawing): Drawing;\n    fuse(other: Drawing): Drawing;\n    intersect(other: Drawing): Drawing;\n    fillet(radius: number, filter?: (c: CornerFinder) => CornerFinder): Drawing;\n    chamfer(radius: number, filter?: (c: CornerFinder) => CornerFinder): Drawing;\n    sketchOnPlane(inputPlane: Plane): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName, origin?: Point | number): SketchInterface | Sketches;\n    sketchOnFace(face: Face, scaleMode: ScaleMode): SketchInterface | Sketches;\n    toSVG(margin?: number): string;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[] | string[][];\n    offset(distance: number): Drawing;\n    approximate(target: \"svg\" | \"arcs\", options?: ApproximationOptions): Drawing;\n    get blueprint(): Blueprint;\n}",
      "signatureWithJSDoc": "export declare class Drawing implements DrawingInterface {\n    constructor(innerShape?: Shape2D);\n    clone(): Drawing;\n    get boundingBox(): BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): Drawing;\n    get repr(): string;\n    rotate(angle: number, center?: Point2D): Drawing;\n    translate(xDist: number, yDist: number): Drawing;\n    translate(translationVector: Point2D): Drawing;\n    scale(scaleFactor: number, center?: Point2D): Drawing;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): Drawing;\n    /**\n     * Builds a new drawing by cuting another drawing into this one\n     *\n     * @category Drawing Modifications\n     */\n    cut(other: Drawing): Drawing;\n    /**\n     * Builds a new drawing by merging another drawing into this one\n     *\n     * @category Drawing Modifications\n     */\n    fuse(other: Drawing): Drawing;\n    /**\n     * Builds a new drawing by intersection this drawing with another\n     *\n     * @category Drawing Modifications\n     */\n    intersect(other: Drawing): Drawing;\n    /**\n     * Creates a new drawing with some corners filletted, as specified by the\n     * radius and the corner finder function\n     *\n     * @category Drawing Modifications\n     */\n    fillet(radius: number, filter?: (c: CornerFinder) => CornerFinder): Drawing;\n    /**\n     * Creates a new drawing with some corners filletted, as specified by the\n     * radius and the corner finder function\n     *\n     * @category Drawing Modifications\n     */\n    chamfer(radius: number, filter?: (c: CornerFinder) => CornerFinder): Drawing;\n    sketchOnPlane(inputPlane: Plane): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName, origin?: Point | number): SketchInterface | Sketches;\n    sketchOnFace(face: Face, scaleMode: ScaleMode): SketchInterface | Sketches;\n    toSVG(margin?: number): string;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[] | string[][];\n    offset(distance: number): Drawing;\n    approximate(target: \"svg\" | \"arcs\", options?: ApproximationOptions): Drawing;\n    get blueprint(): Blueprint;\n}",
      "usageCount": 0
    },
    {
      "name": "DrawingInterface",
      "type": "interface",
      "category": "Drawing & Sketching",
      "signature": "export declare interface DrawingInterface {\n    clone(): DrawingInterface;\n    boundingBox: BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): DrawingInterface;\n    rotate(angle: number, center: Point2D): DrawingInterface;\n    translate(xDist: number, yDist: number): DrawingInterface;\n    translate(translationVector: Point2D): DrawingInterface;\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): DrawingInterface;\n    sketchOnPlane(inputPlane: Plane): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName, origin?: Point | number): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName | Plane, origin?: Point | number): SketchInterface | Sketches;\n    sketchOnFace(face: Face, scaleMode: ScaleMode): SketchInterface | Sketches;\n    toSVG(margin: number): string;\n    toSVGViewBox(margin?: number): string;\n    toSVGPaths(): string[] | string[][];\n}",
      "signatureWithJSDoc": "export declare interface DrawingInterface {\n    clone(): DrawingInterface;\n    boundingBox: BoundingBox2d;\n    stretch(ratio: number, direction: Point2D, origin: Point2D): DrawingInterface;\n    rotate(angle: number, center: Point2D): DrawingInterface;\n    translate(xDist: number, yDist: number): DrawingInterface;\n    translate(translationVector: Point2D): DrawingInterface;\n    /**\n     * Returns the mirror image of this drawing made with a single point (in\n     * center mode, the default, or a plane, (plane mode, with both direction and\n     * origin of the plane).\n     */\n    mirror(centerOrDirection: Point2D, origin?: Point2D, mode?: \"center\" | \"plane\"): DrawingInterface;\n    /**\n     * Returns the sketched version of the drawing, on a plane\n     */\n    sketchOnPlane(inputPlane: Plane): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName, origin?: Point | number): SketchInterface | Sketches;\n    sketchOnPlane(inputPlane?: PlaneName | Plane, origin?: Point | number): SketchInterface | Sketches;\n    /**\n     * Returns the sketched version of the drawing, on a face.\n     *\n     * The scale mode corresponds to the way the coordinates of the drawing are\n     * interpreted match with the face:\n     *\n     * - `original` uses global coordinates (1mm in the drawing is 1mm on the\n     *   face). This is the default, but currently supported only for planar\n     *   and circular faces\n     * - `bounds` normalises the UV parameters on the face to [0,1] intervals.\n     * - `native` uses the default UV parameters of opencascade\n     */\n    sketchOnFace(face: Face, scaleMode: ScaleMode): SketchInterface | Sketches;\n    /**\n     * Formats the drawing as an SVG image\n     */\n    toSVG(margin: number): string;\n    /**\n     * Returns the SVG viewbox that corresponds to this drawing\n     */\n    toSVGViewBox(margin?: number): string;\n    /**\n     * Formats the drawing as a list of SVG paths\n     */\n    toSVGPaths(): string[] | string[][];\n}",
      "usageCount": 0
    },
    {
      "name": "DrawingPen",
      "type": "class",
      "category": "Drawing & Sketching",
      "signature": "export declare class DrawingPen extends BaseSketcher2d implements GenericSketcher<Drawing> {\n    constructor(origin?: Point2D);\n    done(): Drawing;\n    close(): Drawing;\n    closeWithMirror(): Drawing;\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Drawing;\n}",
      "signatureWithJSDoc": "export declare class DrawingPen extends BaseSketcher2d implements GenericSketcher<Drawing> {\n    constructor(origin?: Point2D);\n    done(): Drawing;\n    close(): Drawing;\n    closeWithMirror(): Drawing;\n    /**\n     * Stop drawing, make sure the sketch is closed (by adding a straight line to\n     * from the last point to the first), change the corner between the last and the\n     * first segments and returns the sketch.\n     */\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Drawing;\n}",
      "usageCount": 0
    },
    {
      "name": "drawPointsInterpolation",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const drawPointsInterpolation: (points: Point2D[], approximationConfig?: BSplineApproximationConfig) => Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` by interpolating points as a curve\n *\n * The drawing will be a spline approximating the points. Note that the\n * degree should be at maximum 3 if you need to export the drawing as an SVG.\n *\n * @category Drawing\n */\nexport declare const drawPointsInterpolation: (points: Point2D[], approximationConfig?: BSplineApproximationConfig) => Drawing;",
      "usageCount": 0,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawProjection",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawProjection(shape: AnyShape, projectionCamera?: ProjectionPlane | ProjectionCamera): {\n    visible: Drawing;\n    hidden: Drawing;\n};",
      "signatureWithJSDoc": "export declare function drawProjection(shape: AnyShape, projectionCamera?: ProjectionPlane | ProjectionCamera): {\n    visible: Drawing;\n    hidden: Drawing;\n};",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        },
        {
          "name": "projectionCamera",
          "type": "ProjectionPlane | ProjectionCamera",
          "optional": true
        }
      ],
      "returnType": "{\r\n    visible: Drawing;\r\n    hidden: Drawing;\r\n}",
      "usageCount": 0
    },
    {
      "name": "drawSingleCircle",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawSingleCircle(radius: number): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of a circle as one single curve.\n *\n * The circle is centered on [0, 0]\n *\n * @category Drawing\n */\nexport declare function drawSingleCircle(radius: number): Drawing;",
      "parameters": [
        {
          "name": "radius",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Drawing",
      "usageCount": 0,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawSingleEllipse",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawSingleEllipse(majorRadius: number, minorRadius: number): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of an ellipse as one single curve.\n *\n * The ellipse is centered on [0, 0], with axes aligned with the coordinates.\n *\n * @category Drawing\n */\nexport declare function drawSingleEllipse(majorRadius: number, minorRadius: number): Drawing;",
      "parameters": [
        {
          "name": "majorRadius",
          "type": "number",
          "optional": false
        },
        {
          "name": "minorRadius",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Drawing",
      "usageCount": 0,
      "jsDoc": "Drawing"
    },
    {
      "name": "drawText",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function drawText(text: string, { startX, startY, fontSize, fontFamily }?: {\n    startX?: number | undefined;\n    startY?: number | undefined;\n    fontSize?: number | undefined;\n    fontFamily?: string | undefined;\n}): Drawing;",
      "signatureWithJSDoc": "/**\n * Creates the `Drawing` of a text, in a defined font size and a font familiy\n * (which will be the default).\n *\n * @category Drawing\n */\nexport declare function drawText(text: string, { startX, startY, fontSize, fontFamily }?: {\n    startX?: number | undefined;\n    startY?: number | undefined;\n    fontSize?: number | undefined;\n    fontFamily?: string | undefined;\n}): Drawing;",
      "parameters": [
        {
          "name": "text",
          "type": "string",
          "optional": false
        },
        {
          "name": "{ startX, startY, fontSize, fontFamily }",
          "type": "{\r\n    startX?: number | undefined;\r\n    startY?: number | undefined;\r\n    fontSize?: number | undefined;\r\n    fontFamily?: string | undefined;\r\n}",
          "optional": true
        }
      ],
      "returnType": "Drawing",
      "usageCount": 0,
      "jsDoc": "Drawing"
    },
    {
      "name": "Edge",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class Edge extends _1DShape<TopoDS_Edge> {\n}",
      "signatureWithJSDoc": "export declare class Edge extends _1DShape<TopoDS_Edge> {\n}",
      "usageCount": 0
    },
    {
      "name": "exportSTEP",
      "type": "function",
      "category": "Import/Export",
      "signature": "export declare function exportSTEP(shapes?: ShapeConfig[], { unit, modelUnit }?: {\n    unit?: SupportedUnit;\n    modelUnit?: SupportedUnit;\n}): Blob;",
      "signatureWithJSDoc": "export declare function exportSTEP(shapes?: ShapeConfig[], { unit, modelUnit }?: {\n    unit?: SupportedUnit;\n    modelUnit?: SupportedUnit;\n}): Blob;",
      "parameters": [
        {
          "name": "shapes",
          "type": "ShapeConfig[]",
          "optional": true
        },
        {
          "name": "{ unit, modelUnit }",
          "type": "{\r\n    unit?: SupportedUnit;\r\n    modelUnit?: SupportedUnit;\r\n}",
          "optional": true
        }
      ],
      "returnType": "Blob",
      "usageCount": 0
    },
    {
      "name": "ExtrusionProfile",
      "type": "interface",
      "category": "3D Operations",
      "signature": "export declare interface ExtrusionProfile {\n    profile?: \"s-curve\" | \"linear\";\n    endFactor?: number;\n}",
      "signatureWithJSDoc": "export declare interface ExtrusionProfile {\n    profile?: \"s-curve\" | \"linear\";\n    endFactor?: number;\n}",
      "usageCount": 0
    },
    {
      "name": "Face",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class Face extends Shape<TopoDS_Face> {\n    get surface(): Surface;\n    get orientation(): \"forward\" | \"backward\";\n    get geomType(): SurfaceType;\n    get UVBounds(): {\n        uMin: number;\n        uMax: number;\n        vMin: number;\n        vMax: number;\n    };\n    pointOnSurface(u: number, v: number): Vector;\n    normalAt(locationVector?: Point): Vector;\n    get center(): Vector;\n    outerWire(): Wire;\n    innerWires(): Wire[];\n    triangulation(index0?: number): FaceTriangulation | null;\n}",
      "signatureWithJSDoc": "export declare class Face extends Shape<TopoDS_Face> {\n    get surface(): Surface;\n    get orientation(): \"forward\" | \"backward\";\n    get geomType(): SurfaceType;\n    get UVBounds(): {\n        uMin: number;\n        uMax: number;\n        vMin: number;\n        vMax: number;\n    };\n    pointOnSurface(u: number, v: number): Vector;\n    normalAt(locationVector?: Point): Vector;\n    get center(): Vector;\n    outerWire(): Wire;\n    innerWires(): Wire[];\n    triangulation(index0?: number): FaceTriangulation | null;\n}",
      "usageCount": 0
    },
    {
      "name": "FaceOrEdge",
      "type": "type",
      "category": "Finders & Filters",
      "signature": "declare type FaceOrEdge = Face | Edge;",
      "signatureWithJSDoc": "declare type FaceOrEdge = Face | Edge;",
      "usageCount": 0
    },
    {
      "name": "FaceSketcher",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class FaceSketcher extends BaseSketcher2d implements GenericSketcher<Sketch> {\n    constructor(face: Face, origin?: Point2D);\n    done(): Sketch;\n    close(): Sketch;\n    closeWithMirror(): Sketch;\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Sketch;\n}",
      "signatureWithJSDoc": "/**\n * The FaceSketcher allows you to sketch on a face that is not planar, for\n * instance the sides of a cylinder.\n *\n * The coordinates passed to the methods corresponds to normalised distances on\n * this surface, between 0 and 1 in both direction.\n *\n * Note that if you are drawing on a closed surface (typically a revolution\n * surface or a cylinder), the first parameters represents the angle and can be\n * smaller than 0 or bigger than 1.\n *\n * @category Sketching\n */\nexport declare class FaceSketcher extends BaseSketcher2d implements GenericSketcher<Sketch> {\n    constructor(face: Face, origin?: Point2D);\n    done(): Sketch;\n    close(): Sketch;\n    closeWithMirror(): Sketch;\n    /**\n     * Stop drawing, make sure the sketch is closed (by adding a straight line to\n     * from the last point to the first), add a fillet between the last and the\n     * first segments and returns the sketch.\n     */\n    closeWithCustomCorner(radius: number, mode?: \"fillet\" | \"chamfer\"): Sketch;\n}",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "FaceTriangulation",
      "type": "interface",
      "category": "Finders & Filters",
      "signature": "export declare interface FaceTriangulation {\n    vertices: number[];\n    trianglesIndexes: number[];\n    verticesNormals: number[];\n}",
      "signatureWithJSDoc": "export declare interface FaceTriangulation {\n    vertices: number[];\n    trianglesIndexes: number[];\n    verticesNormals: number[];\n}",
      "usageCount": 0
    },
    {
      "name": "FilterFcn",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type FilterFcn<Type> = {\n    element: Type;\n    normal: Vector | null;\n};",
      "signatureWithJSDoc": "export declare type FilterFcn<Type> = {\n    element: Type;\n    normal: Vector | null;\n};",
      "usageCount": 0
    },
    {
      "name": "Finder",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "declare abstract class Finder<Type, FilterType> {\n    abstract shouldKeep(t: Type): boolean;\n    constructor();\n    delete(): void;\n    and(findersList: ((f: this) => this)[]): this;\n    not(finderFun: (f: this) => this): this;\n    either(findersList: ((f: this) => this)[]): this;\n    find(shape: FilterType, options: {\n        unique: true;\n    }): Type;\n    find(shape: FilterType): Type[];\n    find(shape: FilterType, options: {\n        unique?: false;\n    }): Type[];\n}",
      "signatureWithJSDoc": "declare abstract class Finder<Type, FilterType> {\n    /**\n     * Check if a particular element should be filtered or not according to the\n     * current finder\n     */\n    abstract shouldKeep(t: Type): boolean;\n    constructor();\n    delete(): void;\n    /**\n     * Combine logically a set of filter with an AND operation.\n     *\n     * You need to pass an array of functions that take a finder as a argument\n     * and return the same finder with some filters applied to it.\n     *\n     * Note that by default filters are applied with and AND operation, but in\n     * some case you might want to create them dynamically and use this method.\n     *\n     * @category Filter Combination\n     */\n    and(findersList: ((f: this) => this)[]): this;\n    /**\n     * Invert the result of a particular finder\n     *\n     * You need to pass a function that take a finder as a argument\n     * and return the same finder with some filters applied to it.\n     *\n     * @category Filter Combination\n     */\n    not(finderFun: (f: this) => this): this;\n    /**\n     * Combine logically a set of filter with an OR operation.\n     *\n     * You need to pass an array of functions that take a finder as a argument\n     * and return the same finder with some filters applied to it.\n     *\n     * @category Filter Combination\n     */\n    either(findersList: ((f: this) => this)[]): this;\n    /**\n     * Returns all the elements that fit the set of filters defined on this\n     * finder\n     *\n     * If unique is configured as an option it will either return the unique\n     * element found or throw an error.\n     */\n    find(shape: FilterType, options: {\n        unique: true;\n    }): Type;\n    find(shape: FilterType): Type[];\n    find(shape: FilterType, options: {\n        unique?: false;\n    }): Type[];\n}",
      "usageCount": 0
    },
    {
      "name": "Finder3d",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "declare abstract class Finder3d<Type extends FaceOrEdge> extends Finder<Type, AnyShape> {\n    when(filter: (filter: FilterFcn<Type>) => boolean): this;\n    inList(elementList: Type[]): this;\n    atAngleWith(direction?: Direction_2 | Point, angle?: number): this;\n    atDistance(distance: number, point?: Point): this;\n    containsPoint(point: Point): this;\n    withinDistance(distance: number, point?: Point): this;\n    inBox(corner1: Point, corner2: Point): this;\n    inShape(shape: AnyShape): this;\n}",
      "signatureWithJSDoc": "declare abstract class Finder3d<Type extends FaceOrEdge> extends Finder<Type, AnyShape> {\n    /**\n     * Filter to find elements following a custom function.\n     *\n     * @category Filter\n     */\n    when(filter: (filter: FilterFcn<Type>) => boolean): this;\n    /**\n     * Filter to find elements that are in the list.\n     *\n     * This deletes the elements in the list as the filter deletion.\n     *\n     * @category Filter\n     */\n    inList(elementList: Type[]): this;\n    /**\n     * Filter to find elements that are at a specified angle (in degrees) with\n     * a direction.\n     *\n     * The element direction corresponds to its normal in the case of a face.\n     *\n     * @category Filter\n     */\n    atAngleWith(direction?: Direction_2 | Point, angle?: number): this;\n    /**\n     * Filter to find elements that are at a specified distance from a point.\n     *\n     * @category Filter\n     */\n    atDistance(distance: number, point?: Point): this;\n    /**\n     * Filter to find elements that contain a certain point\n     *\n     * @category Filter\n     */\n    containsPoint(point: Point): this;\n    /**\n     * Filter to find elements that are within a certain distance from a point.\n     *\n     * @category Filter\n     */\n    withinDistance(distance: number, point?: Point): this;\n    /**\n     * Filter to find elements that are within a box\n     *\n     * The elements that are not fully contained in the box are also found.\n     *\n     * @category Filter\n     */\n    inBox(corner1: Point, corner2: Point): this;\n    /**\n     * Filter to find elements that are within a generic shape\n     *\n     * The elements that are not fully contained in the shape are also found.\n     *\n     * @category Filter\n     */\n    inShape(shape: AnyShape): this;\n}",
      "usageCount": 0
    },
    {
      "name": "fuse2D",
      "type": "constant",
      "category": "Modifications",
      "signature": "export declare const fuse2D: (first: Shape2D, second: Shape2D) => Blueprint | Blueprints | CompoundBlueprint | null;",
      "signatureWithJSDoc": "export declare const fuse2D: (first: Shape2D, second: Shape2D) => Blueprint | Blueprints | CompoundBlueprint | null;",
      "usageCount": 0
    },
    {
      "name": "fuseBlueprints",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const fuseBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "signatureWithJSDoc": "export declare const fuseBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "usageCount": 0
    },
    {
      "name": "GCWithObject",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const GCWithObject: (obj: any) => <Type extends Deletable>(value: Type) => Type;",
      "signatureWithJSDoc": "export declare const GCWithObject: (obj: any) => <Type extends Deletable>(value: Type) => Type;",
      "usageCount": 0
    },
    {
      "name": "GCWithScope",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const GCWithScope: () => <Type extends Deletable>(value: Type) => Type;",
      "signatureWithJSDoc": "export declare const GCWithScope: () => <Type extends Deletable>(value: Type) => Type;",
      "usageCount": 0
    },
    {
      "name": "GenericSketcher",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface GenericSketcher<ReturnType> {\n    movePointerTo(point: Point2D): this;\n    lineTo(point: Point2D): this;\n    line(xDist: number, yDist: number): this;\n    vLine(distance: number): this;\n    hLine(distance: number): this;\n    vLineTo(yPos: number): this;\n    hLineTo(xPos: number): this;\n    polarLineTo([r, theta]: [\n        number,\n        number\n    ]): this;\n    polarLine(r: number, theta: number): this;\n    tangentLine(distance: number): this;\n    threePointsArcTo(end: Point2D, innerPoint: Point2D): this;\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    vSagittaArc(distance: number, sagitta: number): this;\n    hSagittaArc(distance: number, sagitta: number): this;\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    vBulgeArc(distance: number, bulge: number): this;\n    hBulgeArc(distance: number, bulge: number): this;\n    tangentArcTo(end: Point2D): this;\n    tangentArc(xDist: number, yDist: number): this;\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation: number, longAxis: boolean, sweep: boolean): this;\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation: number, longAxis: boolean, sweep: boolean): this;\n    halfEllipseTo(end: Point2D, radius: number, sweep: boolean): this;\n    halfEllipse(xDist: number, yDist: number, radius: number, sweep: boolean): this;\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    smoothSpline(xDist: number, yDist: number, splineConfig: SplineConfig): this;\n    done(): ReturnType;\n    close(): ReturnType;\n    closeWithMirror(): ReturnType;\n}",
      "signatureWithJSDoc": "/**\n * Sketchers allow the user to draw a two dimentional shape using segment of\n * curve. You start by defining where you sketch will start (with the method\n * `movePointerTo`.\n * Each sketching method corresponds to drawing a curve of some type (line,\n * arc, elliptic arc, bezier curve to a new point. The next segment will start\n * from the end point of the previous segment.\n * Once you end your sketch you will receive a `Sketch` object that allows you\n * to give some three dimentionlity to your finished sketch.\n *\n * @category Sketching\n */\nexport declare interface GenericSketcher<ReturnType> {\n    /**\n     * Changes the point to start your drawing from\n     */\n    movePointerTo(point: Point2D): this;\n    /**\n     * Draws a line from the current point to the point given in argument\n     *\n     * @category Line Segment\n     */\n    lineTo(point: Point2D): this;\n    /**\n     * Draws a line at the horizontal distance xDist and the vertical distance\n     * yDist of the current point\n     *\n     * @category Line Segment\n     */\n    line(xDist: number, yDist: number): this;\n    /**\n     * Draws a vertical line of length distance from the current point\n     *\n     * @category Line Segment\n     */\n    vLine(distance: number): this;\n    /**\n     * Draws an horizontal line of length distance from the current point\n     *\n     * @category Line Segment\n     */\n    hLine(distance: number): this;\n    /**\n     * Draws a vertical line to the y coordinate\n     *\n     * @category Line Segment\n     */\n    vLineTo(yPos: number): this;\n    /**\n     * Draws an horizontal line to the x coordinate\n     *\n     * @category Line Segment\n     */\n    hLineTo(xPos: number): this;\n    /**\n     * Draws a line from the current point to the point defined in polar\n     * coordiates, of radius r and angle theta (in degrees) from the origin\n     *\n     * @category Line Segment\n     */\n    polarLineTo([r, theta]: [\n        number,\n        number\n    ]): this;\n    /**\n     * Draws a line from the current point to the point defined in polar\n     * coordiates, of radius r and angle theta (in degrees) from the current\n     * point\n     *\n     * @category Line Segment\n     */\n    polarLine(r: number, theta: number): this;\n    /**\n     * Draws a line from the current point as a tangent to the previous part of\n     * curve drawn. The distance defines how long the line will be.\n     *\n     * @category Line Segment\n     */\n    tangentLine(distance: number): this;\n    /** Draws an arc of circle by defining its end point and a third point\n     * through which the arc will pass.\n     *\n     * @category Arc Segment\n     */\n    threePointsArcTo(end: Point2D, innerPoint: Point2D): this;\n    /** Draws an arc of circle by defining its end point and a third point\n     * through which the arc will pass. Both poinats are defined in horizontal\n     * (x) and vertical (y) distances from the start point.\n     *\n     * @category Arc Segment\n     */\n    threePointsArc(xDist: number, yDist: number, viaXDist: number, viaYDist: number): this;\n    /** Draws an arc of circle by defining its end point and the sagitta - the\n     * maximum distance between the arc and the straight line going from start to\n     * end point.\n     *\n     * @category Arc Segment\n     */\n    sagittaArcTo(end: Point2D, sagitta: number): this;\n    /** Draws an arc of circle by defining its end point and the sagitta - the\n     * maximum distance between the arc and the straight line going from start to\n     * end point.The end point is defined by its horizontal and vertical\n     * distances from the start point.\n     *\n     * @category Arc Segment\n     */\n    sagittaArc(xDist: number, yDist: number, sagitta: number): this;\n    /** Draws a vertical arc of circle by defining its end point and the sagitta\n     * - the maximum distance between the arc and the straight line going from\n     * start to end point.The end point is defined by its  vertical distance from\n     * the start point.\n     *\n     * @category Arc Segment\n     */\n    vSagittaArc(distance: number, sagitta: number): this;\n    /** Draws an horizontal arc of circle by defining its end point and the\n     * sagitta - the maximum distance between the arc and the straight line going\n     * from start to end point.The end point is defined by its horizontal\n     * distance from the start point.\n     *\n     * @category Arc Segment\n     */\n    hSagittaArc(distance: number, sagitta: number): this;\n    /** Draws an arc of circle by defining its end point and the bulge - the\n     * maximum distance between the arc and the straight line going from start to\n     * end point.\n     *\n     * @category Arc Segment\n     */\n    bulgeArcTo(end: Point2D, bulge: number): this;\n    /** Draws an arc of circle by defining its end point and the bulge - the\n     * maximum distance between the arc and the straight line going from start to\n     * end point in units of half the chord. The end point is defined by its horizontal and vertical distances\n     * from the start point.\n     *\n     * @category Arc Segment\n     */\n    bulgeArc(xDist: number, yDist: number, bulge: number): this;\n    /** Draws a vertical arc of circle by defining its end point and the bulge\n     * - the maximum distance between the arc and the straight line going from\n     * start to end point in units of half the chord. The end point is defined by its  vertical distance from\n     * the start point.\n     *\n     * @category Arc Segment\n     */\n    vBulgeArc(distance: number, bulge: number): this;\n    /** Draws an horizontal arc of circle by defining its end point and the bulge\n     * - the maximum distance between the arc and the straight line going from\n     * start to end point in units of half the chord. The end point is defined by\n     * its horizontal distance from the start point.\n     *\n     * @category Arc Segment\n     */\n    hBulgeArc(distance: number, bulge: number): this;\n    /**\n     * Draws an arc of circle from the current point as a tangent to the previous\n     * part of curve drawn.\n     *\n     * @category Arc Segment\n     */\n    tangentArcTo(end: Point2D): this;\n    /**\n     * Draws an arc of circle from the current point as a tangent to the previous\n     * part of curve drawn.The end point is defined by its horizontal and vertical\n     * distances from the start point.\n     *\n     * @category Arc Segment\n     */\n    tangentArc(xDist: number, yDist: number): this;\n    /**\n     * Draws an arc of ellipse by defining its end point and an ellipse.\n     *\n     * The  shape of the ellipse is defined by both its radiuses, its angle\n     * relative to the current coordinat system, as well as the long and sweep\n     * flags (as defined for SVG paths)\n     *\n     * @category Ellipse Arc Segment\n     */\n    ellipseTo(end: Point2D, horizontalRadius: number, verticalRadius: number, rotation: number, longAxis: boolean, sweep: boolean): this;\n    /**\n     * Draws an arc of ellipse by defining its end point and an ellipse. The end\n     * point is defined by distances from he start point.\n     *\n     * The  shape of the ellipse is defined by both its radiuses, its angle\n     * relative to the current coordinat system, as well as the long and sweep\n     * flags (as defined for SVG paths)\n     *\n     * @category Ellipse Arc Segment\n     */\n    ellipse(xDist: number, yDist: number, horizontalRadius: number, verticalRadius: number, rotation: number, longAxis: boolean, sweep: boolean): this;\n    /**\n     * Draws an arc as half an ellipse, defined by the sagitta of the ellipse\n     * (which corresponds to the radius in the axe orthogonal to the straight\n     * line).\n     *\n     * The sweep flag is to be understood as defined for SVG paths.\n     *\n     * @category Ellipse Arc Segment\n     */\n    halfEllipseTo(end: Point2D, radius: number, sweep: boolean): this;\n    /**\n     * Draws an arc as half an ellipse, defined by the sagitta of the ellipse\n     * (which corresponds to the radius in the axe orthogonal to the straight\n     * line).The end point is defined by distances from he start point.\n     *\n     * The sweep flag is to be understood as defined for SVG paths.\n     *\n     * @category Ellipse Arc Segment\n     */\n    halfEllipse(xDist: number, yDist: number, radius: number, sweep: boolean): this;\n    /** Draws a generic bezier curve to the end point, going using a set of\n     * control points.\n     *\n     * This is the generic definition of a bzier curve, you might want to use\n     * either the quadratic or cubic (most common) version, unless you know\n     * exactly what you are aiming at.\n     *\n     * @category Bezier Curve\n     */\n    bezierCurveTo(end: Point2D, controlPoints: Point2D | Point2D[]): this;\n    /** Draws a quadratic bezier curve to the end point, using the single control\n     * point.\n     *\n     * @category Bezier Curve\n     */\n    quadraticBezierCurveTo(end: Point2D, controlPoint: Point2D): this;\n    /** Draws a cubic bezier curve to the end point, using the start  and end\n     * control point to define its shape. This corresponds to the most commonly\n     * used bezier curve.\n     *\n     * If you are struggling setting your control points, the smoothSpline might\n     * be better for your needs.\n     *\n     * @category Bezier Curve\n     */\n    cubicBezierCurveTo(end: Point2D, startControlPoint: Point2D, endControlPoint: Point2D): this;\n    /** Draws a cubic bezier curve to the end point, attempting to make the line\n     * smooth with the previous segment.\n     *\n     * It will base its first control point so that its tangent is the same than\n     * the previous segment.\n     *\n     * The control point relative to the end is by default set to be in the\n     * direction of the straight line between start and end. You can specifiy the\n     * `endSkew` either as an angle (in degrees) to this direction, or as an\n     * absolute direction in the coordinate system (a Point).\n     *\n     * The start- and end- factors decide on how far the control point is from\n     * the start and end point. At a factor of 1, the distance corresponds to\n     * a quarter of the straight line distance.\n     *\n     * @category Bezier Curve\n     */\n    smoothSplineTo(end: Point2D, config?: SplineConfig): this;\n    /** Draws a cubic bezier curve to the end point, attempting to make the line\n     * smooth with the previous segment. The end point is defined by its distance\n     * to the first point.\n     *\n     * It will base its first control point so that its tangent is the same than\n     * the previous segment. You can force another tangent by defining\n     * `startTangent`.\n     *\n     * You can configure the tangent of the end point by configuring the\n     * `endTangent`, either as \"symmetric\" to reproduce the start angle, as an\n     * angle from the X axis (in the coordinate system) or a 2d direction (still\n     * in the coordinate system.\n     *\n     * The start- and end- factors decide on how far the control point is from\n     * the start and end point. At a factor of 1, the distance corresponds to\n     * a quarter of the straight line distance.\n     *\n     * @category Bezier Curve\n     */\n    smoothSpline(xDist: number, yDist: number, splineConfig: SplineConfig): this;\n    /**\n     * Stop drawing and returns the sketch.\n     */\n    done(): ReturnType;\n    /**\n     * Stop drawing, make sure the sketch is closed (by adding a straight line to\n     * from the last point to the first) and returns the sketch.\n     */\n    close(): ReturnType;\n    /**\n     * Stop drawing, make sure the sketch is closed (by mirroring the lines\n     * between the first and last points drawn) and returns the sketch.\n     */\n    closeWithMirror(): ReturnType;\n}",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "genericSweep",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function genericSweep(wire: Wire, spine: Wire, sweepConfig: GenericSweepConfig, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "signatureWithJSDoc": "export declare function genericSweep(wire: Wire, spine: Wire, sweepConfig: GenericSweepConfig, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "spine",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "sweepConfig",
          "type": "GenericSweepConfig",
          "optional": false
        },
        {
          "name": "shellMode",
          "type": "true",
          "optional": false
        }
      ],
      "returnType": "[Shape3D, Wire, Wire]",
      "usageCount": 0
    },
    {
      "name": "genericSweep",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function genericSweep(wire: Wire, spine: Wire, sweepConfig: GenericSweepConfig, shellMode?: false): Shape3D;",
      "signatureWithJSDoc": "export declare function genericSweep(wire: Wire, spine: Wire, sweepConfig: GenericSweepConfig, shellMode?: false): Shape3D;",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "spine",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "sweepConfig",
          "type": "GenericSweepConfig",
          "optional": false
        },
        {
          "name": "shellMode",
          "type": "false",
          "optional": true
        }
      ],
      "returnType": "Shape3D",
      "usageCount": 0
    },
    {
      "name": "GenericSweepConfig",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface GenericSweepConfig {\n    frenet?: boolean;\n    auxiliarySpine?: Wire | Edge;\n    law?: null | Handle_Law_Function;\n    transitionMode?: \"right\" | \"transformed\" | \"round\";\n    withContact?: boolean;\n    support?: TopoDS_Shape;\n    forceProfileSpineOthogonality?: boolean;\n}",
      "signatureWithJSDoc": "export declare interface GenericSweepConfig {\n    frenet?: boolean;\n    auxiliarySpine?: Wire | Edge;\n    law?: null | Handle_Law_Function;\n    transitionMode?: \"right\" | \"transformed\" | \"round\";\n    withContact?: boolean;\n    support?: TopoDS_Shape;\n    forceProfileSpineOthogonality?: boolean;\n}",
      "usageCount": 0
    },
    {
      "name": "GenericTopo",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type GenericTopo = TopoDS_Face | TopoDS_Shape | TopoDS_Edge | TopoDS_Wire | TopoDS_Shell | TopoDS_Vertex | TopoDS_Solid | TopoDS_Compound | TopoDS_CompSolid;",
      "signatureWithJSDoc": "declare type GenericTopo = TopoDS_Face | TopoDS_Shape | TopoDS_Edge | TopoDS_Wire | TopoDS_Shell | TopoDS_Vertex | TopoDS_Solid | TopoDS_Compound | TopoDS_CompSolid;",
      "usageCount": 0
    },
    {
      "name": "getFont",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const getFont: (fontFamily?: string) => opentype_2.Font;",
      "signatureWithJSDoc": "export declare const getFont: (fontFamily?: string) => opentype_2.Font;",
      "usageCount": 0
    },
    {
      "name": "getOC",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const getOC: () => OpenCascadeInstance;",
      "signatureWithJSDoc": "export declare const getOC: () => OpenCascadeInstance;",
      "usageCount": 0
    },
    {
      "name": "HASH_CODE_MAX",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const HASH_CODE_MAX = 2147483647;",
      "signatureWithJSDoc": "export declare const HASH_CODE_MAX = 2147483647;",
      "usageCount": 0
    },
    {
      "name": "importSTEP",
      "type": "function",
      "category": "Import/Export",
      "signature": "export declare function importSTEP(STLBlob: Blob): Promise<AnyShape>;",
      "signatureWithJSDoc": "/**\n * Creates a new shapes from a STEP file (as a Blob or a File).\n *\n * @category Import\n */\nexport declare function importSTEP(STLBlob: Blob): Promise<AnyShape>;",
      "parameters": [
        {
          "name": "STLBlob",
          "type": "Blob",
          "optional": false
        }
      ],
      "returnType": "Promise<AnyShape>",
      "usageCount": 0,
      "jsDoc": "Import"
    },
    {
      "name": "importSTL",
      "type": "function",
      "category": "Import/Export",
      "signature": "export declare function importSTL(STLBlob: Blob): Promise<AnyShape>;",
      "signatureWithJSDoc": "/** Creates a new shapes from a STL file (as a Blob or a File).\n *\n * This process can be relatively long depending on how much tesselation has\n * been done to your STL.\n *\n * This function tries to clean a bit the triangulation of faces, but can fail\n * in bad ways.\n *\n * @category Import\n */\nexport declare function importSTL(STLBlob: Blob): Promise<AnyShape>;",
      "parameters": [
        {
          "name": "STLBlob",
          "type": "Blob",
          "optional": false
        }
      ],
      "returnType": "Promise<AnyShape>",
      "usageCount": 0,
      "jsDoc": "Import"
    },
    {
      "name": "intersect2D",
      "type": "function",
      "category": "Modifications",
      "signature": "export declare function intersect2D(first: Shape2D, second: Shape2D): Blueprint | Blueprints | CompoundBlueprint | null;",
      "signatureWithJSDoc": "export declare function intersect2D(first: Shape2D, second: Shape2D): Blueprint | Blueprints | CompoundBlueprint | null;",
      "parameters": [
        {
          "name": "first",
          "type": "Shape2D",
          "optional": false
        },
        {
          "name": "second",
          "type": "Shape2D",
          "optional": false
        }
      ],
      "returnType": "Blueprint | Blueprints | CompoundBlueprint | null",
      "usageCount": 0
    },
    {
      "name": "intersectBlueprints",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const intersectBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "signatureWithJSDoc": "export declare const intersectBlueprints: (first: Blueprint, second: Blueprint) => null | Blueprint | Blueprints;",
      "usageCount": 0
    },
    {
      "name": "isPoint",
      "type": "function",
      "category": "Geometry Types",
      "signature": "export declare function isPoint(p: unknown): p is Point;",
      "signatureWithJSDoc": "export declare function isPoint(p: unknown): p is Point;",
      "parameters": [
        {
          "name": "p",
          "type": "unknown",
          "optional": false
        }
      ],
      "returnType": "p is Point",
      "usageCount": 0
    },
    {
      "name": "isProjectionPlane",
      "type": "function",
      "category": "Geometry Types",
      "signature": "export declare function isProjectionPlane(plane: unknown): plane is ProjectionPlane;",
      "signatureWithJSDoc": "export declare function isProjectionPlane(plane: unknown): plane is ProjectionPlane;",
      "parameters": [
        {
          "name": "plane",
          "type": "unknown",
          "optional": false
        }
      ],
      "returnType": "plane is ProjectionPlane",
      "usageCount": 0
    },
    {
      "name": "isShape3D",
      "type": "function",
      "category": "Geometry Types",
      "signature": "export declare function isShape3D(shape: AnyShape): shape is Shape3D;",
      "signatureWithJSDoc": "export declare function isShape3D(shape: AnyShape): shape is Shape3D;",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        }
      ],
      "returnType": "shape is Shape3D",
      "usageCount": 0
    },
    {
      "name": "isWire",
      "type": "function",
      "category": "Finders & Filters",
      "signature": "export declare function isWire(shape: AnyShape): shape is Wire;",
      "signatureWithJSDoc": "export declare function isWire(shape: AnyShape): shape is Wire;",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        }
      ],
      "returnType": "shape is Wire",
      "usageCount": 0
    },
    {
      "name": "iterTopo",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const iterTopo: (shape: TopoDS_Shape, topo: TopoEntity) => IterableIterator<TopoDS_Shape>;",
      "signatureWithJSDoc": "export declare const iterTopo: (shape: TopoDS_Shape, topo: TopoEntity) => IterableIterator<TopoDS_Shape>;",
      "usageCount": 0
    },
    {
      "name": "LinearPhysicalProperties",
      "type": "class",
      "category": "Measurements",
      "signature": "export declare class LinearPhysicalProperties extends PhysicalProperties {\n    get length(): number;\n}",
      "signatureWithJSDoc": "export declare class LinearPhysicalProperties extends PhysicalProperties {\n    get length(): number;\n}",
      "usageCount": 0
    },
    {
      "name": "loadFont",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const loadFont: (fontPath: string, fontFamily?: string) => Promise<opentype_2.Font>;",
      "signatureWithJSDoc": "/**\n * Import a font in the text system. If the font family is not defined it will\n * set its name as \"default\"\n *\n * The font should be in TTF\n */\nexport declare const loadFont: (fontPath: string, fontFamily?: string) => Promise<opentype_2.Font>;",
      "usageCount": 0
    },
    {
      "name": "localGC",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const localGC: (debug?: boolean) => [\n    <T extends Deletable>(v: T) => T,\n    () => void,\n    Set<Deletable> | undefined\n];",
      "signatureWithJSDoc": "export declare const localGC: (debug?: boolean) => [\n    <T extends Deletable>(v: T) => T,\n    () => void,\n    Set<Deletable> | undefined\n];",
      "usageCount": 0
    },
    {
      "name": "loft",
      "type": "constant",
      "category": "3D Operations",
      "signature": "export declare const loft: (wires: Wire[], { ruled, startPoint, endPoint }?: LoftConfig, returnShell?: boolean) => Shape3D;",
      "signatureWithJSDoc": "export declare const loft: (wires: Wire[], { ruled, startPoint, endPoint }?: LoftConfig, returnShell?: boolean) => Shape3D;",
      "usageCount": 0
    },
    {
      "name": "LoftConfig",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface LoftConfig {\n    ruled?: boolean;\n    startPoint?: Point;\n    endPoint?: Point;\n}",
      "signatureWithJSDoc": "export declare interface LoftConfig {\n    ruled?: boolean;\n    startPoint?: Point;\n    endPoint?: Point;\n}",
      "usageCount": 0
    },
    {
      "name": "lookFromPlane",
      "type": "function",
      "category": "Geometry Types",
      "signature": "export declare function lookFromPlane(projectionPlane: ProjectionPlane): ProjectionCamera;",
      "signatureWithJSDoc": "export declare function lookFromPlane(projectionPlane: ProjectionPlane): ProjectionCamera;",
      "parameters": [
        {
          "name": "projectionPlane",
          "type": "ProjectionPlane",
          "optional": false
        }
      ],
      "returnType": "ProjectionCamera",
      "usageCount": 0
    },
    {
      "name": "makeAx1",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeAx1: (center: Point, dir: Point) => gp_Ax1;",
      "signatureWithJSDoc": "export declare const makeAx1: (center: Point, dir: Point) => gp_Ax1;",
      "usageCount": 0
    },
    {
      "name": "makeAx2",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeAx2: (center: Point, dir: Point, xDir?: Point) => gp_Ax2;",
      "signatureWithJSDoc": "export declare const makeAx2: (center: Point, dir: Point, xDir?: Point) => gp_Ax2;",
      "usageCount": 0
    },
    {
      "name": "makeAx3",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeAx3: (center: Point, dir: Point, xDir?: Point) => gp_Ax3;",
      "signatureWithJSDoc": "export declare const makeAx3: (center: Point, dir: Point, xDir?: Point) => gp_Ax3;",
      "usageCount": 0
    },
    {
      "name": "makeBaseBox",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeBaseBox: (xLength: number, yLength: number, zLength: number) => Shape3D;",
      "signatureWithJSDoc": "export declare const makeBaseBox: (xLength: number, yLength: number, zLength: number) => Shape3D;",
      "usageCount": 0
    },
    {
      "name": "makeBezierCurve",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeBezierCurve: (points: Point[]) => Edge;",
      "signatureWithJSDoc": "export declare const makeBezierCurve: (points: Point[]) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeBox",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeBox: (corner1: Point, corner2: Point) => Solid;",
      "signatureWithJSDoc": "export declare const makeBox: (corner1: Point, corner2: Point) => Solid;",
      "usageCount": 0
    },
    {
      "name": "makeBSplineApproximation",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeBSplineApproximation: (points: Point[], { tolerance, smoothing, degMax, degMin, }?: BSplineApproximationConfig) => Edge;",
      "signatureWithJSDoc": "export declare const makeBSplineApproximation: (points: Point[], { tolerance, smoothing, degMax, degMin, }?: BSplineApproximationConfig) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeCircle",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeCircle: (radius: number, center?: Point, normal?: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeCircle: (radius: number, center?: Point, normal?: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeCompound",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeCompound: (shapeArray: AnyShape[]) => AnyShape;",
      "signatureWithJSDoc": "export declare const makeCompound: (shapeArray: AnyShape[]) => AnyShape;",
      "usageCount": 0
    },
    {
      "name": "makeDirection",
      "type": "function",
      "category": "Primitives & Makers",
      "signature": "export declare function makeDirection(p: Direction): Point;",
      "signatureWithJSDoc": "export declare function makeDirection(p: Direction): Point;",
      "parameters": [
        {
          "name": "p",
          "type": "Direction",
          "optional": false
        }
      ],
      "returnType": "Point",
      "usageCount": 0
    },
    {
      "name": "makeEllipse",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeEllipse: (majorRadius: number, minorRadius: number, center?: Point, normal?: Point, xDir?: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeEllipse: (majorRadius: number, minorRadius: number, center?: Point, normal?: Point, xDir?: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeEllipseArc",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeEllipseArc: (majorRadius: number, minorRadius: number, startAngle: number, endAngle: number, center?: Point, normal?: Point, xDir?: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeEllipseArc: (majorRadius: number, minorRadius: number, startAngle: number, endAngle: number, center?: Point, normal?: Point, xDir?: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeEllipsoid",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeEllipsoid: (aLength: number, bLength: number, cLength: number) => Solid;",
      "signatureWithJSDoc": "export declare const makeEllipsoid: (aLength: number, bLength: number, cLength: number) => Solid;",
      "usageCount": 0
    },
    {
      "name": "makeHelix",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeHelix: (pitch: number, height: number, radius: number, center?: Point, dir?: Point, lefthand?: boolean) => Wire;",
      "signatureWithJSDoc": "export declare const makeHelix: (pitch: number, height: number, radius: number, center?: Point, dir?: Point, lefthand?: boolean) => Wire;",
      "usageCount": 0
    },
    {
      "name": "makeLine",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeLine: (v1: Point, v2: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeLine: (v1: Point, v2: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeNewFaceWithinFace",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeNewFaceWithinFace: (originFace: Face, wire: Wire) => Face;",
      "signatureWithJSDoc": "export declare const makeNewFaceWithinFace: (originFace: Face, wire: Wire) => Face;",
      "usageCount": 0
    },
    {
      "name": "makeNonPlanarFace",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeNonPlanarFace: (wire: Wire) => Face;",
      "signatureWithJSDoc": "export declare const makeNonPlanarFace: (wire: Wire) => Face;",
      "usageCount": 0
    },
    {
      "name": "makePlaneFromFace",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makePlaneFromFace: (face: Face, originOnSurface?: Point2D) => Plane;",
      "signatureWithJSDoc": "export declare const makePlaneFromFace: (face: Face, originOnSurface?: Point2D) => Plane;",
      "usageCount": 0
    },
    {
      "name": "makePolygon",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makePolygon: (points: Point[]) => Face;",
      "signatureWithJSDoc": "export declare const makePolygon: (points: Point[]) => Face;",
      "usageCount": 0
    },
    {
      "name": "makeProjectedEdges",
      "type": "function",
      "category": "Primitives & Makers",
      "signature": "export declare function makeProjectedEdges(shape: AnyShape, camera: ProjectionCamera, withHiddenLines?: boolean): {\n    visible: Edge[];\n    hidden: Edge[];\n};",
      "signatureWithJSDoc": "export declare function makeProjectedEdges(shape: AnyShape, camera: ProjectionCamera, withHiddenLines?: boolean): {\n    visible: Edge[];\n    hidden: Edge[];\n};",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        },
        {
          "name": "camera",
          "type": "ProjectionCamera",
          "optional": false
        },
        {
          "name": "withHiddenLines",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "{\r\n    visible: Edge[];\r\n    hidden: Edge[];\r\n}",
      "usageCount": 0
    },
    {
      "name": "makeTangentArc",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeTangentArc: (startPoint: Point, startTgt: Point, endPoint: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeTangentArc: (startPoint: Point, startTgt: Point, endPoint: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeThreePointArc",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeThreePointArc: (v1: Point, v2: Point, v3: Point) => Edge;",
      "signatureWithJSDoc": "export declare const makeThreePointArc: (v1: Point, v2: Point, v3: Point) => Edge;",
      "usageCount": 0
    },
    {
      "name": "makeVertex",
      "type": "constant",
      "category": "Primitives & Makers",
      "signature": "export declare const makeVertex: (point: Point) => Vertex;",
      "signatureWithJSDoc": "export declare const makeVertex: (point: Point) => Vertex;",
      "usageCount": 0
    },
    {
      "name": "measureArea",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureArea(shape: Face | Shape3D): number;",
      "signatureWithJSDoc": "/**\n * Measure the area of a shape\n *\n * @category Measure\n */\nexport declare function measureArea(shape: Face | Shape3D): number;",
      "parameters": [
        {
          "name": "shape",
          "type": "Face | Shape3D",
          "optional": false
        }
      ],
      "returnType": "number",
      "usageCount": 0,
      "jsDoc": "Measure"
    },
    {
      "name": "measureDistanceBetween",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureDistanceBetween(shape1: AnyShape, shape2: AnyShape): number;",
      "signatureWithJSDoc": "/**\n * Measure the distance between two shapes\n *\n * @category Measure\n */\nexport declare function measureDistanceBetween(shape1: AnyShape, shape2: AnyShape): number;",
      "parameters": [
        {
          "name": "shape1",
          "type": "AnyShape",
          "optional": false
        },
        {
          "name": "shape2",
          "type": "AnyShape",
          "optional": false
        }
      ],
      "returnType": "number",
      "usageCount": 0,
      "jsDoc": "Measure"
    },
    {
      "name": "measureLength",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureLength(shape: AnyShape): number;",
      "signatureWithJSDoc": "/**\n * Measure the length of a shape\n *\n * @category Measure\n */\nexport declare function measureLength(shape: AnyShape): number;",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        }
      ],
      "returnType": "number",
      "usageCount": 0,
      "jsDoc": "Measure"
    },
    {
      "name": "measureShapeLinearProperties",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureShapeLinearProperties(shape: AnyShape): LinearPhysicalProperties;",
      "signatureWithJSDoc": "export declare function measureShapeLinearProperties(shape: AnyShape): LinearPhysicalProperties;",
      "parameters": [
        {
          "name": "shape",
          "type": "AnyShape",
          "optional": false
        }
      ],
      "returnType": "LinearPhysicalProperties",
      "usageCount": 0
    },
    {
      "name": "measureShapeSurfaceProperties",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureShapeSurfaceProperties(shape: Face | Shape3D): SurfacePhysicalProperties;",
      "signatureWithJSDoc": "export declare function measureShapeSurfaceProperties(shape: Face | Shape3D): SurfacePhysicalProperties;",
      "parameters": [
        {
          "name": "shape",
          "type": "Face | Shape3D",
          "optional": false
        }
      ],
      "returnType": "SurfacePhysicalProperties",
      "usageCount": 0
    },
    {
      "name": "measureShapeVolumeProperties",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureShapeVolumeProperties(shape: Shape3D): VolumePhysicalProperties;",
      "signatureWithJSDoc": "export declare function measureShapeVolumeProperties(shape: Shape3D): VolumePhysicalProperties;",
      "parameters": [
        {
          "name": "shape",
          "type": "Shape3D",
          "optional": false
        }
      ],
      "returnType": "VolumePhysicalProperties",
      "usageCount": 0
    },
    {
      "name": "measureVolume",
      "type": "function",
      "category": "Measurements",
      "signature": "export declare function measureVolume(shape: Shape3D): number;",
      "signatureWithJSDoc": "/**\n * Measure the volume of a shape\n *\n * @category Measure\n */\nexport declare function measureVolume(shape: Shape3D): number;",
      "parameters": [
        {
          "name": "shape",
          "type": "Shape3D",
          "optional": false
        }
      ],
      "returnType": "number",
      "usageCount": 0,
      "jsDoc": "Measure"
    },
    {
      "name": "organiseBlueprints",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const organiseBlueprints: (blueprints: Blueprint[]) => Blueprints;",
      "signatureWithJSDoc": "/**\n * Groups an array of blueprints such that blueprints that correspond to holes\n * in other blueprints are set in a `CompoundBlueprint`.\n *\n * The current algorithm does not handle cases where blueprints cross each\n * other\n */\nexport declare const organiseBlueprints: (blueprints: Blueprint[]) => Blueprints;",
      "usageCount": 0
    },
    {
      "name": "PhysicalProperties",
      "type": "class",
      "category": "Measurements",
      "signature": "declare class PhysicalProperties extends WrappingObj<GProp_GProps> {\n    get centerOfMass(): [\n        number,\n        number,\n        number\n    ];\n}",
      "signatureWithJSDoc": "declare class PhysicalProperties extends WrappingObj<GProp_GProps> {\n    get centerOfMass(): [\n        number,\n        number,\n        number\n    ];\n}",
      "usageCount": 0
    },
    {
      "name": "PlaneConfig",
      "type": "interface",
      "category": "Geometry Types",
      "signature": "declare interface PlaneConfig {\n    plane?: PlaneName | Plane;\n    origin?: Point | number;\n}",
      "signatureWithJSDoc": "declare interface PlaneConfig {\n    plane?: PlaneName | Plane;\n    origin?: Point | number;\n}",
      "usageCount": 0
    },
    {
      "name": "PlaneName",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type PlaneName = \"XY\" | \"YZ\" | \"ZX\" | \"XZ\" | \"YX\" | \"ZY\" | \"front\" | \"back\" | \"left\" | \"right\" | \"top\" | \"bottom\";",
      "signatureWithJSDoc": "export declare type PlaneName = \"XY\" | \"YZ\" | \"ZX\" | \"XZ\" | \"YX\" | \"ZY\" | \"front\" | \"back\" | \"left\" | \"right\" | \"top\" | \"bottom\";",
      "usageCount": 0
    },
    {
      "name": "Point",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type Point = SimplePoint | Vector | [\n    number,\n    number\n] | {\n    XYZ: () => gp_XYZ;\n    delete: () => void;\n};",
      "signatureWithJSDoc": "export declare type Point = SimplePoint | Vector | [\n    number,\n    number\n] | {\n    XYZ: () => gp_XYZ;\n    delete: () => void;\n};",
      "usageCount": 0
    },
    {
      "name": "Point2D",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type Point2D = [\n    number,\n    number\n];",
      "signatureWithJSDoc": "export declare type Point2D = [\n    number,\n    number\n];",
      "usageCount": 0
    },
    {
      "name": "polysidesBlueprint",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const polysidesBlueprint: (radius: number, sidesCount: number, sagitta?: number) => Blueprint;",
      "signatureWithJSDoc": "export declare const polysidesBlueprint: (radius: number, sidesCount: number, sagitta?: number) => Blueprint;",
      "usageCount": 0
    },
    {
      "name": "ProjectionCamera",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class ProjectionCamera extends WrappingObj<gp_Ax2> {\n    constructor(position?: Point, direction?: Point, xAxis?: Point);\n    get position(): Vector;\n    get direction(): Vector;\n    get xAxis(): Vector;\n    get yAxis(): Vector;\n    autoAxes(): void;\n    setPosition(position: Point): this;\n    setXAxis(xAxis: Point): this;\n    setYAxis(yAxis: Point): this;\n    lookAt(shape: {\n        boundingBox: BoundingBox;\n    } | Point): this;\n}",
      "signatureWithJSDoc": "export declare class ProjectionCamera extends WrappingObj<gp_Ax2> {\n    constructor(position?: Point, direction?: Point, xAxis?: Point);\n    get position(): Vector;\n    get direction(): Vector;\n    get xAxis(): Vector;\n    get yAxis(): Vector;\n    autoAxes(): void;\n    setPosition(position: Point): this;\n    setXAxis(xAxis: Point): this;\n    setYAxis(yAxis: Point): this;\n    lookAt(shape: {\n        boundingBox: BoundingBox;\n    } | Point): this;\n}",
      "usageCount": 0
    },
    {
      "name": "ProjectionPlane",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type ProjectionPlane = \"XY\" | \"XZ\" | \"YZ\" | \"YX\" | \"ZX\" | \"ZY\" | \"front\" | \"back\" | \"top\" | \"bottom\" | \"left\" | \"right\";",
      "signatureWithJSDoc": "export declare type ProjectionPlane = \"XY\" | \"XZ\" | \"YZ\" | \"YX\" | \"ZX\" | \"ZY\" | \"front\" | \"back\" | \"top\" | \"bottom\" | \"left\" | \"right\";",
      "usageCount": 0
    },
    {
      "name": "RAD2DEG",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const RAD2DEG: number;",
      "signatureWithJSDoc": "export declare const RAD2DEG: number;",
      "usageCount": 0
    },
    {
      "name": "RadiusConfig",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type RadiusConfig = ((e: Edge) => number | null) | number | {\n    filter: EdgeFinder;\n    radius: number;\n    keep?: boolean;\n};",
      "signatureWithJSDoc": "/**\n * A generic way to define radii for fillet or chamfer (the operation)\n *\n * If the radius is a filter finder object (with an EdgeFinder as filter, and\n * a radius to specify the fillet radius), the operation will only be applied\n * to the edges as selected by the finder. The finder will be deleted unless it\n * is explicitly specified to `keep` it.\n *\n * If the radius is a number all the edges will be targetted for the operation.\n *\n * If the radius is a function edges will be filletted or chamfered according\n * to the value returned by the function (0 or null will not add any fillet).\n */\nexport declare type RadiusConfig = ((e: Edge) => number | null) | number | {\n    filter: EdgeFinder;\n    radius: number;\n    keep?: boolean;\n};",
      "usageCount": 0
    },
    {
      "name": "roundedRectangleBlueprint",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const roundedRectangleBlueprint: (width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}) => Blueprint;",
      "signatureWithJSDoc": "export declare const roundedRectangleBlueprint: (width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}) => Blueprint;",
      "usageCount": 0
    },
    {
      "name": "ScaleMode",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type ScaleMode = \"original\" | \"bounds\" | \"native\";",
      "signatureWithJSDoc": "export declare type ScaleMode = \"original\" | \"bounds\" | \"native\";",
      "usageCount": 0
    },
    {
      "name": "setOC",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const setOC: (oc: OpenCascadeInstance) => void;",
      "signatureWithJSDoc": "export declare const setOC: (oc: OpenCascadeInstance) => void;",
      "usageCount": 0
    },
    {
      "name": "Shape2D",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type Shape2D = Blueprint | Blueprints | CompoundBlueprint | null;",
      "signatureWithJSDoc": "export declare type Shape2D = Blueprint | Blueprints | CompoundBlueprint | null;",
      "usageCount": 0
    },
    {
      "name": "Shape3D",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type Shape3D = Shell | Solid | CompSolid | Compound;",
      "signatureWithJSDoc": "export declare type Shape3D = Shell | Solid | CompSolid | Compound;",
      "usageCount": 0
    },
    {
      "name": "ShapeConfig",
      "type": "type",
      "category": "Geometry Types",
      "signature": "declare type ShapeConfig = {\n    shape: AnyShape;\n    color?: string;\n    alpha?: number;\n    name?: string;\n};",
      "signatureWithJSDoc": "declare type ShapeConfig = {\n    shape: AnyShape;\n    color?: string;\n    alpha?: number;\n    name?: string;\n};",
      "usageCount": 0
    },
    {
      "name": "ShapeMesh",
      "type": "interface",
      "category": "Geometry Types",
      "signature": "export declare interface ShapeMesh {\n    triangles: number[];\n    vertices: number[];\n    normals: number[];\n    faceGroups: {\n        start: number;\n        count: number;\n        faceId: number;\n    }[];\n}",
      "signatureWithJSDoc": "export declare interface ShapeMesh {\n    triangles: number[];\n    vertices: number[];\n    normals: number[];\n    faceGroups: {\n        start: number;\n        count: number;\n        faceId: number;\n    }[];\n}",
      "usageCount": 0
    },
    {
      "name": "shapeType",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const shapeType: (shape: TopoDS_Shape) => TopAbs_ShapeEnum;",
      "signatureWithJSDoc": "export declare const shapeType: (shape: TopoDS_Shape) => TopAbs_ShapeEnum;",
      "usageCount": 0
    },
    {
      "name": "SimplePoint",
      "type": "type",
      "category": "Geometry Types",
      "signature": "export declare type SimplePoint = [\n    number,\n    number,\n    number\n];",
      "signatureWithJSDoc": "export declare type SimplePoint = [\n    number,\n    number,\n    number\n];",
      "usageCount": 0
    },
    {
      "name": "sketchEllipse",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchEllipse: (xRadius?: number, yRadius?: number, planeConfig?: PlaneConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of an ellispe in a defined plane\n *\n * @category Sketching\n */\nexport declare const sketchEllipse: (xRadius?: number, yRadius?: number, planeConfig?: PlaneConfig) => Sketch;",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "Sketches",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Sketches {\n    sketches: Array<Sketch | CompoundSketch>;\n    constructor(sketches: Array<Sketch | CompoundSketch>);\n    wires(): AnyShape;\n    faces(): AnyShape;\n    extrude(extrusionDistance: number, extrusionConfig?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    revolve(revolutionAxis?: Point, config?: {\n        origin?: Point;\n    }): Shape3D;\n}",
      "signatureWithJSDoc": "export declare class Sketches {\n    sketches: Array<Sketch | CompoundSketch>;\n    constructor(sketches: Array<Sketch | CompoundSketch>);\n    wires(): AnyShape;\n    faces(): AnyShape;\n    /** Extrudes the sketch to a certain distance.(along the default direction\n     * and origin of the sketch).\n     *\n     * You can define another extrusion direction or origin,\n     *\n     * It is also possible to twist extrude with an angle (in degrees), or to\n     * give a profile to the extrusion (the endFactor will scale the face, and\n     * the profile will define how the scale is applied (either linarly or with\n     * a s-shape).\n     */\n    extrude(extrusionDistance: number, extrusionConfig?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    /**\n     * Revolves the drawing on an axis (defined by its direction and an origin\n     * (defaults to the sketch origin)\n     */\n    revolve(revolutionAxis?: Point, config?: {\n        origin?: Point;\n    }): Shape3D;\n}",
      "usageCount": 0
    },
    {
      "name": "sketchFaceOffset",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchFaceOffset: (face: Face, offset: number) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of an offset of a certain face. A negative offset will\n * be within the face, a positive one outside.\n *\n * @category Sketching\n */\nexport declare const sketchFaceOffset: (face: Face, offset: number) => Sketch;",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "sketchHelix",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchHelix: (pitch: number, height: number, radius: number, center?: Point, dir?: Point, lefthand?: boolean) => Sketch;",
      "signatureWithJSDoc": "export declare const sketchHelix: (pitch: number, height: number, radius: number, center?: Point, dir?: Point, lefthand?: boolean) => Sketch;",
      "usageCount": 0
    },
    {
      "name": "SketchInterface",
      "type": "interface",
      "category": "Utilities",
      "signature": "export declare interface SketchInterface {\n    face(): Face;\n    revolve(revolutionAxis?: Point, config?: {\n        origin?: Point;\n    }): Shape3D;\n    extrude(extrusionDistance: number, extrusionConfig?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    loftWith(otherSketches: this | this[], loftConfig: LoftConfig, returnShell?: boolean): Shape3D;\n}",
      "signatureWithJSDoc": "export declare interface SketchInterface {\n    /**\n     * Transforms the lines into a face. The lines should be closed.\n     */\n    face(): Face;\n    /**\n     * Revolves the drawing on an axis (defined by its direction and an origin\n     * (defaults to the sketch origin)\n     */\n    revolve(revolutionAxis?: Point, config?: {\n        origin?: Point;\n    }): Shape3D;\n    /**\n     * Extrudes the sketch to a certain distance.(along the default direction\n     * and origin of the sketch).\n     *\n     * You can define another extrusion direction or origin,\n     *\n     * It is also possible to twist extrude with an angle (in degrees), or to\n     * give a profile to the extrusion (the endFactor will scale the face, and\n     * the profile will define how the scale is applied (either linarly or with\n     * a s-shape).\n     */\n    extrude(extrusionDistance: number, extrusionConfig?: {\n        extrusionDirection?: Point;\n        extrusionProfile?: ExtrusionProfile;\n        twistAngle?: number;\n        origin?: Point;\n    }): Shape3D;\n    /**\n     * Loft between this sketch and another sketch (or an array of them)\n     *\n     * You can also define a `startPoint` for the loft (that will be placed\n     * before this sketch) and an `endPoint` after the last one.\n     *\n     * You can also define if you want the loft to result in a ruled surface.\n     *\n     * Note that all sketches will be deleted by this operation\n     */\n    loftWith(otherSketches: this | this[], loftConfig: LoftConfig, returnShell?: boolean): Shape3D;\n}",
      "usageCount": 0
    },
    {
      "name": "sketchParametricFunction",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchParametricFunction: (func: (t: number) => Point2D, planeConfig?: PlaneConfig, { pointsCount, start, stop }?: {\n    pointsCount?: number | undefined;\n    start?: number | undefined;\n    stop?: number | undefined;\n}, approximationConfig?: BSplineApproximationConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of parametric function in a specified plane\n *\n * The sketch will be a spline approximating the function\n *\n * @category Sketching\n */\nexport declare const sketchParametricFunction: (func: (t: number) => Point2D, planeConfig?: PlaneConfig, { pointsCount, start, stop }?: {\n    pointsCount?: number | undefined;\n    start?: number | undefined;\n    stop?: number | undefined;\n}, approximationConfig?: BSplineApproximationConfig) => Sketch;",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "sketchPolysides",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchPolysides: (radius: number, sidesCount: number, sagitta?: number, planeConfig?: PlaneConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of an polygon in a defined plane\n *\n * The sides of the polygon can be arcs of circle with a defined sagitta.\n * The radius defines the out radius of the polygon without sagitta\n *\n * @category Sketching\n */\nexport declare const sketchPolysides: (radius: number, sidesCount: number, sagitta?: number, planeConfig?: PlaneConfig) => Sketch;",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "sketchRoundedRectangle",
      "type": "constant",
      "category": "Drawing & Sketching",
      "signature": "export declare const sketchRoundedRectangle: (width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}, planeConfig?: PlaneConfig) => Sketch;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketch` of a rounded rectangle in a defined plane\n *\n * @category Sketching\n */\nexport declare const sketchRoundedRectangle: (width: number, height: number, r?: number | {\n    rx?: number;\n    ry?: number;\n}, planeConfig?: PlaneConfig) => Sketch;",
      "usageCount": 0,
      "jsDoc": "Sketching"
    },
    {
      "name": "sketchText",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function sketchText(text: string, textConfig?: {\n    startX?: number;\n    startY?: number;\n    fontSize?: number;\n    fontFamily?: \"string\";\n}, planeConfig?: {\n    plane?: PlaneName | Plane;\n    origin?: Point | number;\n}): Sketches;",
      "signatureWithJSDoc": "/**\n * Creates the `Sketches` of a text, in a defined font size and a font familiy\n * (which will be the default).\n */\nexport declare function sketchText(text: string, textConfig?: {\n    startX?: number;\n    startY?: number;\n    fontSize?: number;\n    fontFamily?: \"string\";\n}, planeConfig?: {\n    plane?: PlaneName | Plane;\n    origin?: Point | number;\n}): Sketches;",
      "parameters": [
        {
          "name": "text",
          "type": "string",
          "optional": false
        },
        {
          "name": "textConfig",
          "type": "{\r\n    startX?: number;\r\n    startY?: number;\r\n    fontSize?: number;\r\n    fontFamily?: \"string\";\r\n}",
          "optional": true
        },
        {
          "name": "planeConfig",
          "type": "{\r\n    plane?: PlaneName | Plane;\r\n    origin?: Point | number;\r\n}",
          "optional": true
        }
      ],
      "returnType": "Sketches",
      "usageCount": 0
    },
    {
      "name": "Solid",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Solid extends _3DShape<TopoDS_Solid> {\n}",
      "signatureWithJSDoc": "export declare class Solid extends _3DShape<TopoDS_Solid> {\n}",
      "usageCount": 0
    },
    {
      "name": "SplineConfig",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type SplineConfig = SplineTangent | {\n    endTangent?: SplineTangent;\n    startTangent?: StartSplineTangent;\n    startFactor?: number;\n    endFactor?: number;\n};",
      "signatureWithJSDoc": "export declare type SplineConfig = SplineTangent | {\n    endTangent?: SplineTangent;\n    startTangent?: StartSplineTangent;\n    startFactor?: number;\n    endFactor?: number;\n};",
      "usageCount": 0
    },
    {
      "name": "SplineTangent",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type SplineTangent = StartSplineTangent | \"symmetric\";",
      "signatureWithJSDoc": "declare type SplineTangent = StartSplineTangent | \"symmetric\";",
      "usageCount": 0
    },
    {
      "name": "StandardPlane",
      "type": "type",
      "category": "Geometry Types",
      "signature": "declare type StandardPlane = \"XY\" | \"XZ\" | \"YZ\";",
      "signatureWithJSDoc": "declare type StandardPlane = \"XY\" | \"XZ\" | \"YZ\";",
      "usageCount": 0
    },
    {
      "name": "StartSplineTangent",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type StartSplineTangent = number | Point2D;",
      "signatureWithJSDoc": "declare type StartSplineTangent = number | Point2D;",
      "usageCount": 0
    },
    {
      "name": "SupportedUnit",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type SupportedUnit = \"M\" | \"CM\" | \"MM\" | \"INCH\" | \"FT\" | \"m\" | \"mm\" | \"cm\" | \"inch\" | \"ft\";",
      "signatureWithJSDoc": "export declare type SupportedUnit = \"M\" | \"CM\" | \"MM\" | \"INCH\" | \"FT\" | \"m\" | \"mm\" | \"cm\" | \"inch\" | \"ft\";",
      "usageCount": 0
    },
    {
      "name": "supportExtrude",
      "type": "constant",
      "category": "Utilities",
      "signature": "export declare const supportExtrude: (wire: Wire, center: Point, normal: Point, support: TopoDS_Shape) => Shape3D;",
      "signatureWithJSDoc": "export declare const supportExtrude: (wire: Wire, center: Point, normal: Point, support: TopoDS_Shape) => Shape3D;",
      "usageCount": 0
    },
    {
      "name": "Surface",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class Surface extends WrappingObj<Adaptor3d_Surface> {\n    get surfaceType(): SurfaceType;\n}",
      "signatureWithJSDoc": "export declare class Surface extends WrappingObj<Adaptor3d_Surface> {\n    get surfaceType(): SurfaceType;\n}",
      "usageCount": 0
    },
    {
      "name": "SurfacePhysicalProperties",
      "type": "class",
      "category": "Measurements",
      "signature": "export declare class SurfacePhysicalProperties extends PhysicalProperties {\n    get area(): number;\n}",
      "signatureWithJSDoc": "export declare class SurfacePhysicalProperties extends PhysicalProperties {\n    get area(): number;\n}",
      "usageCount": 0
    },
    {
      "name": "SurfaceType",
      "type": "type",
      "category": "Utilities",
      "signature": "export declare type SurfaceType = \"PLANE\" | \"CYLINDRE\" | \"CONE\" | \"SPHERE\" | \"TORUS\" | \"BEZIER_SURFACE\" | \"BSPLINE_SURFACE\" | \"REVOLUTION_SURFACE\" | \"EXTRUSION_SURFACE\" | \"OFFSET_SURFACE\" | \"OTHER_SURFACE\";",
      "signatureWithJSDoc": "export declare type SurfaceType = \"PLANE\" | \"CYLINDRE\" | \"CONE\" | \"SPHERE\" | \"TORUS\" | \"BEZIER_SURFACE\" | \"BSPLINE_SURFACE\" | \"REVOLUTION_SURFACE\" | \"EXTRUSION_SURFACE\" | \"OFFSET_SURFACE\" | \"OTHER_SURFACE\";",
      "usageCount": 0
    },
    {
      "name": "textBlueprints",
      "type": "function",
      "category": "Drawing & Sketching",
      "signature": "export declare function textBlueprints(text: string, { startX, startY, fontSize, fontFamily }?: {\n    startX?: number | undefined;\n    startY?: number | undefined;\n    fontSize?: number | undefined;\n    fontFamily?: string | undefined;\n}): Blueprints;",
      "signatureWithJSDoc": "/**\n * Creates the `Blueprints` of a text, in a defined font size and a font familiy\n * (which will be the default).\n */\nexport declare function textBlueprints(text: string, { startX, startY, fontSize, fontFamily }?: {\n    startX?: number | undefined;\n    startY?: number | undefined;\n    fontSize?: number | undefined;\n    fontFamily?: string | undefined;\n}): Blueprints;",
      "parameters": [
        {
          "name": "text",
          "type": "string",
          "optional": false
        },
        {
          "name": "{ startX, startY, fontSize, fontFamily }",
          "type": "{\r\n    startX?: number | undefined;\r\n    startY?: number | undefined;\r\n    fontSize?: number | undefined;\r\n    fontFamily?: string | undefined;\r\n}",
          "optional": true
        }
      ],
      "returnType": "Blueprints",
      "usageCount": 0
    },
    {
      "name": "TopoEntity",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type TopoEntity = \"vertex\" | \"edge\" | \"wire\" | \"face\" | \"shell\" | \"solid\" | \"solidCompound\" | \"compound\" | \"shape\";",
      "signatureWithJSDoc": "declare type TopoEntity = \"vertex\" | \"edge\" | \"wire\" | \"face\" | \"shell\" | \"solid\" | \"solidCompound\" | \"compound\" | \"shape\";",
      "usageCount": 0
    },
    {
      "name": "Transformation",
      "type": "class",
      "category": "Transformations",
      "signature": "export declare class Transformation extends WrappingObj<gp_Trsf> {\n    constructor(transform?: gp_Trsf);\n    translate(xDist: number, yDist: number, zDist: number): Transformation;\n    translate(vector: Point): Transformation;\n    rotate(angle: number, position?: Point, direction?: Point): Transformation;\n    mirror(inputPlane?: Plane | PlaneName | Point, inputOrigin?: Point): this;\n    scale(center: Point, scale: number): this;\n    coordSystemChange(fromSystem: CoordSystem, toSystem: CoordSystem): this;\n    transformPoint(point: Point): gp_Pnt;\n    transform(shape: TopoDS_Shape): TopoDS_Shape;\n}",
      "signatureWithJSDoc": "export declare class Transformation extends WrappingObj<gp_Trsf> {\n    constructor(transform?: gp_Trsf);\n    translate(xDist: number, yDist: number, zDist: number): Transformation;\n    translate(vector: Point): Transformation;\n    rotate(angle: number, position?: Point, direction?: Point): Transformation;\n    mirror(inputPlane?: Plane | PlaneName | Point, inputOrigin?: Point): this;\n    scale(center: Point, scale: number): this;\n    coordSystemChange(fromSystem: CoordSystem, toSystem: CoordSystem): this;\n    transformPoint(point: Point): gp_Pnt;\n    transform(shape: TopoDS_Shape): TopoDS_Shape;\n}",
      "usageCount": 0
    },
    {
      "name": "twistExtrude",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function twistExtrude(wire: Wire, angleDegrees: number, center: Point, normal: Point, profileShape?: ExtrusionProfile, shellMode?: false): Shape3D;",
      "signatureWithJSDoc": "export declare function twistExtrude(wire: Wire, angleDegrees: number, center: Point, normal: Point, profileShape?: ExtrusionProfile, shellMode?: false): Shape3D;",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "angleDegrees",
          "type": "number",
          "optional": false
        },
        {
          "name": "center",
          "type": "Point",
          "optional": false
        },
        {
          "name": "normal",
          "type": "Point",
          "optional": false
        },
        {
          "name": "profileShape",
          "type": "ExtrusionProfile",
          "optional": true
        },
        {
          "name": "shellMode",
          "type": "false",
          "optional": true
        }
      ],
      "returnType": "Shape3D",
      "usageCount": 0
    },
    {
      "name": "twistExtrude",
      "type": "function",
      "category": "Utilities",
      "signature": "export declare function twistExtrude(wire: Wire, angleDegrees: number, center: Point, normal: Point, profileShape: ExtrusionProfile | undefined, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "signatureWithJSDoc": "export declare function twistExtrude(wire: Wire, angleDegrees: number, center: Point, normal: Point, profileShape: ExtrusionProfile | undefined, shellMode: true): [\n    Shape3D,\n    Wire,\n    Wire\n];",
      "parameters": [
        {
          "name": "wire",
          "type": "Wire",
          "optional": false
        },
        {
          "name": "angleDegrees",
          "type": "number",
          "optional": false
        },
        {
          "name": "center",
          "type": "Point",
          "optional": false
        },
        {
          "name": "normal",
          "type": "Point",
          "optional": false
        },
        {
          "name": "profileShape",
          "type": "ExtrusionProfile | undefined",
          "optional": false
        },
        {
          "name": "shellMode",
          "type": "true",
          "optional": false
        }
      ],
      "returnType": "[Shape3D, Wire, Wire]",
      "usageCount": 0
    },
    {
      "name": "UVBounds",
      "type": "type",
      "category": "Utilities",
      "signature": "declare type UVBounds = {\n    uMin: number;\n    uMax: number;\n    vMin: number;\n    vMax: number;\n};",
      "signatureWithJSDoc": "declare type UVBounds = {\n    uMin: number;\n    uMax: number;\n    vMin: number;\n    vMax: number;\n};",
      "usageCount": 0
    },
    {
      "name": "Vertex",
      "type": "class",
      "category": "Geometry Types",
      "signature": "export declare class Vertex extends Shape<TopoDS_Vertex> {\n}",
      "signatureWithJSDoc": "export declare class Vertex extends Shape<TopoDS_Vertex> {\n}",
      "usageCount": 0
    },
    {
      "name": "VolumePhysicalProperties",
      "type": "class",
      "category": "Measurements",
      "signature": "export declare class VolumePhysicalProperties extends PhysicalProperties {\n    get volume(): number;\n}",
      "signatureWithJSDoc": "export declare class VolumePhysicalProperties extends PhysicalProperties {\n    get volume(): number;\n}",
      "usageCount": 0
    },
    {
      "name": "weldShellsAndFaces",
      "type": "function",
      "category": "Finders & Filters",
      "signature": "export declare function weldShellsAndFaces(facesOrShells: Array<Face | Shell>, ignoreType?: boolean): Shell;",
      "signatureWithJSDoc": "/** Welds faces and shells into a single shell.\n *\n * @param facesOrShells - An array of faces and shells to be welded.\n * @param ignoreType - If true, the function will not check if the result is\n * a shell.\n * @returns A shell that contains all the faces and shells.\n * */\nexport declare function weldShellsAndFaces(facesOrShells: Array<Face | Shell>, ignoreType?: boolean): Shell;",
      "parameters": [
        {
          "name": "facesOrShells",
          "type": "Array<Face | Shell>",
          "optional": false
        },
        {
          "name": "ignoreType",
          "type": "boolean",
          "optional": true
        }
      ],
      "returnType": "Shell",
      "usageCount": 0,
      "jsDoc": "- An array of faces and shells to be welded. - If true, the function will not check if the result is\r\na shell. A shell that contains all the faces and shells."
    },
    {
      "name": "Wire",
      "type": "class",
      "category": "Finders & Filters",
      "signature": "export declare class Wire extends _1DShape<TopoDS_Wire> {\n    offset2D(offset: number, kind?: \"arc\" | \"intersection\" | \"tangent\"): Wire;\n}",
      "signatureWithJSDoc": "export declare class Wire extends _1DShape<TopoDS_Wire> {\n    offset2D(offset: number, kind?: \"arc\" | \"intersection\" | \"tangent\"): Wire;\n}",
      "usageCount": 0
    },
    {
      "name": "WrappingObj",
      "type": "class",
      "category": "Utilities",
      "signature": "export declare class WrappingObj<Type extends Deletable> {\n    constructor(wrapped: Type);\n    get wrapped(): Type;\n    set wrapped(newWrapped: Type);\n    delete(): void;\n}",
      "signatureWithJSDoc": "export declare class WrappingObj<Type extends Deletable> {\n    constructor(wrapped: Type);\n    get wrapped(): Type;\n    set wrapped(newWrapped: Type);\n    delete(): void;\n}",
      "usageCount": 0
    }
  ],
  "stats": {
    "kept": [
      {
        "name": "_1DShape.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.curve",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.startPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.endPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.tangentAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_1DShape.pointAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_1DShape.isClosed",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.isPeriodic",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.period",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.geomType",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.length",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape.orientation",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "_1DShape",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "_3DShape.fuse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.cut",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.intersect",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.shell",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.shell",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.fillet",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape.chamfer",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "_3DShape",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "addHolesInFace",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "AnyShape",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "ApproximationOptions",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "asDir",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "asPnt",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "assembleWire",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "AssemblyExporter",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "axis2d",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "BaseSketcher2d.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.movePointerTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.lineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.line",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.vLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.hLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.vLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.hLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.polarLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.polarLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.tangentLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.threePointsArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.threePointsArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.sagittaArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.sagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.vSagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.hSagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.bulgeArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.bulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.vBulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.hBulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.tangentArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.tangentArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.ellipseTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.ellipse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.halfEllipseTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.halfEllipse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.bezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.quadraticBezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.cubicBezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.smoothSplineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.smoothSpline",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d.customCorner",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BaseSketcher2d",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "basicFaceExtrusion",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Blueprint.curves",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.orientation",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.stretch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.sketchOnPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.sketchOnFace",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.toSVGPathD",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.toSVGPath",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.toSVGViewBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.toSVGPaths",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.toSVG",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.firstPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.lastPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprint.isInside",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.isClosed",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint.intersects",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprint",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Blueprints.blueprints",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Blueprints.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprints.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Blueprints.stretch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.sketchOnPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.sketchOnFace",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.toSVGViewBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.toSVGPaths",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints.toSVG",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Blueprints",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "BlueprintSketcher.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "BlueprintSketcher.done",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BlueprintSketcher.close",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BlueprintSketcher.closeWithMirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BlueprintSketcher.closeWithCustomCorner",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BlueprintSketcher",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "BoundingBox.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.bounds",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.center",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.width",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.height",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.depth",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.add",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox.isOut",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "BoundingBox2d.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.bounds",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.center",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.width",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.height",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.outsidePoint",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.add",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.isOut",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d.containsPoint",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "BoundingBox2d",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "BSplineApproximationConfig",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "cast",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "combineFinderFilters",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "complexExtrude",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "complexExtrude",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "Compound",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "CompoundBlueprint.blueprints",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.stretch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.sketchOnPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.sketchOnFace",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.toSVGViewBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.toSVGPaths",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.toSVGGroup",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint.toSVG",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundBlueprint",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "compoundShapes",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "CompoundSketch.sketches",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.outerSketch",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.innerSketches",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.wires",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.face",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.extrude",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.revolve",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch.loftWith",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CompoundSketch",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "CompSolid",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "CoordSystem",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Corner",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "CornerFinder.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.inList",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.atDistance",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.atPoint",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.inBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.ofAngle",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder.shouldKeep",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "CornerFinder",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "createAssembly",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "createNamedPlane",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "CubeFace",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Curve.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.curveType",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.startPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.endPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.pointAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve.tangentAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve.isClosed",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.isPeriodic",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve.period",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Curve2D.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.innerCurve",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.value",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.firstPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.lastPoint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.firstParameter",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.lastParameter",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.adaptor",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.geomType",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Curve2D.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.reverse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.distanceFrom",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.isOnCurve",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.parameter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.tangentAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D.splitAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Curve2D",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "CurveLike",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "CurveType",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "cut2D",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "cutBlueprints",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "DEG2RAD",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Deletable",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "Direction",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Direction_2",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "DistanceQuery.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "DistanceQuery.distanceTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DistanceQuery",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "DistanceTool.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "DistanceTool.distanceBetween",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DistanceTool",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "downcast",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "draw",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawCircle",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawEllipse",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawFaceOutline",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "Drawing.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Drawing.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Drawing.stretch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Drawing.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.cut",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.fuse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.intersect",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.fillet",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.chamfer",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.sketchOnPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.sketchOnPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.sketchOnFace",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.toSVG",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.toSVGViewBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.toSVGPaths",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.offset",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.approximate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Drawing.blueprint",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Drawing",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "DrawingInterface",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "DrawingPen.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "DrawingPen.done",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DrawingPen.close",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DrawingPen.closeWithMirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DrawingPen.closeWithCustomCorner",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "DrawingPen",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "drawParametricFunction",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "drawPointsInterpolation",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "drawPolysides",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawProjection",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawRectangle",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "drawRoundedRectangle",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawSingleCircle",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawSingleEllipse",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "drawText",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "Edge",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "EdgeFinder.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.inDirection",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.ofLength",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.ofCurveType",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.parallelTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.inPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder.shouldKeep",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "EdgeFinder",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "exportSTEP",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "ExtrusionProfile",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "Face.surface",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Face.orientation",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Face.geomType",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Face.UVBounds",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Face.pointOnSurface",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Face.normalAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Face.center",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Face.outerWire",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Face.innerWires",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Face.triangulation",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Face",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "FaceFinder.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceFinder.parallelTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceFinder.ofSurfaceType",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceFinder.inPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceFinder.shouldKeep",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceFinder",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "FaceOrEdge",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "FaceSketcher.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "FaceSketcher.done",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceSketcher.close",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceSketcher.closeWithMirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceSketcher.closeWithCustomCorner",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "FaceSketcher",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "FaceTriangulation",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "FilterFcn",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Finder.shouldKeep",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Finder.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.and",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.not",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.either",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.find",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.find",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder.find",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Finder3d.when",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.inList",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.atAngleWith",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.atDistance",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.containsPoint",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.withinDistance",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.inBox",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d.inShape",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Finder3d",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "fuse2D",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "fuseBlueprints",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "GCWithObject",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "GCWithScope",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "GenericSketcher",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "genericSweep",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "genericSweep",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "GenericSweepConfig",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "GenericTopo",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "getFont",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "getOC",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "HASH_CODE_MAX",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "importSTEP",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "importSTL",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "intersect2D",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "intersectBlueprints",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "isPoint",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "isProjectionPlane",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "isShape3D",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "isWire",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "iterTopo",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "LinearPhysicalProperties.length",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "LinearPhysicalProperties",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "loadFont",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "localGC",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "loft",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "LoftConfig",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "lookFromPlane",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makeAx1",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeAx2",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeAx3",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeBaseBox",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeBezierCurve",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeBox",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeBSplineApproximation",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeCircle",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeCompound",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeCylinder",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeDirection",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makeEllipse",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeEllipseArc",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeEllipsoid",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeFace",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeHelix",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeLine",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeNewFaceWithinFace",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeNonPlanarFace",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeOffset",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makePlane",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makePlane",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makePlaneFromFace",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makePolygon",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeProjectedEdges",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makeSolid",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "makeSphere",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeTangentArc",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeThreePointArc",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "makeVertex",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "measureArea",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureDistanceBetween",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureLength",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureShapeLinearProperties",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureShapeSurfaceProperties",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureShapeVolumeProperties",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "measureVolume",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "mirror",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "organiseBlueprints",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "PhysicalProperties.centerOfMass",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "PhysicalProperties",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Plane.xDir",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.yDir",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.zDir",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Plane.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.origin",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Plane.origin",
        "type": "class member",
        "nodeType": "SetAccessor",
        "reason": "public member"
      },
      {
        "name": "Plane.translateTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.translateX",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.translateY",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.translateZ",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.pivot",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.rotate2DAxes",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.setOrigin2d",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.toLocalCoords",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane.toWorldCoords",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Plane",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "PlaneConfig",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "PlaneName",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Point",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Point2D",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "polysideInnerRadius",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "polysidesBlueprint",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "ProjectionCamera.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.position",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.direction",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.xAxis",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.yAxis",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.autoAxes",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.setPosition",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.setXAxis",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.setYAxis",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera.lookAt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "ProjectionCamera",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "ProjectionPlane",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "RAD2DEG",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "RadiusConfig",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "revolution",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "rotate",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "roundedRectangleBlueprint",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "scale",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "ScaleMode",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "setOC",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Shape.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Shape.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.hashCode",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.isNull",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.isSame",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.isEqual",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.simplify",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.translateX",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.translateY",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.translateZ",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.edges",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.faces",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.wires",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.boundingBox",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Shape.mesh",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.meshEdges",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.blobSTEP",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape.blobSTL",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Shape",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Shape2D",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Shape3D",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "ShapeConfig",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "ShapeMesh",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "shapeType",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Shell",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "SimplePoint",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Sketch.wire",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Sketch.baseFace",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.baseFace",
        "type": "class member",
        "nodeType": "SetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.clone",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.defaultOrigin",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.defaultOrigin",
        "type": "class member",
        "nodeType": "SetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.defaultDirection",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.defaultDirection",
        "type": "class member",
        "nodeType": "SetAccessor",
        "reason": "public member"
      },
      {
        "name": "Sketch.face",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.wires",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.faces",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.revolve",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.extrude",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.sweepSketch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch.loftWith",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketch",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "sketchCircle",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchEllipse",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Sketcher.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Sketcher.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Sketcher.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.movePointerTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.lineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.line",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.vLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.hLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.vLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.hLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.polarLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.polarLineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.tangentLine",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.threePointsArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.threePointsArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.tangentArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.tangentArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.sagittaArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.sagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.vSagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.hSagittaArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.bulgeArcTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.bulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.vBulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.hBulgeArc",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.ellipseTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.ellipse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.halfEllipseTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.halfEllipse",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.bezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.quadraticBezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.cubicBezierCurveTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.smoothSplineTo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.smoothSpline",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.done",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.close",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher.closeWithMirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketcher",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Sketches.sketches",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketches.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Sketches.wires",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketches.faces",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketches.extrude",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketches.revolve",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Sketches",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "sketchFaceOffset",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchHelix",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "SketchInterface",
        "type": "interface",
        "nodeType": "InterfaceDeclaration",
        "reason": "exported interface"
      },
      {
        "name": "sketchParametricFunction",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchPolysides",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchRectangle",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchRoundedRectangle",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "sketchText",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "Solid",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "SplineConfig",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "SplineTangent",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "StandardPlane",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "StartSplineTangent",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "SupportedUnit",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "supportExtrude",
        "type": "constant",
        "nodeType": "FirstStatement",
        "reason": "exported constant"
      },
      {
        "name": "Surface.surfaceType",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Surface",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "SurfacePhysicalProperties.area",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "SurfacePhysicalProperties",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "SurfaceType",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "textBlueprints",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "TopoEntity",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Transformation.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Transformation.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.translate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.mirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.scale",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.coordSystemChange",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.transformPoint",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation.transform",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Transformation",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "translate",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "twistExtrude",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "twistExtrude",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "UVBounds",
        "type": "type",
        "nodeType": "TypeAliasDeclaration",
        "reason": "exported type alias"
      },
      {
        "name": "Vector.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "Vector.repr",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Vector.x",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Vector.y",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Vector.z",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Vector.Length",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "Vector.toTuple",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.cross",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.dot",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.sub",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.add",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.multiply",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.normalized",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.normalize",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.getCenter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.getAngle",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.projectToPlane",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.equals",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.toPnt",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.toDir",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector.rotate",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Vector",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "Vertex",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "VolumePhysicalProperties.volume",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "VolumePhysicalProperties",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "weldShellsAndFaces",
        "type": "function",
        "nodeType": "FunctionDeclaration",
        "reason": "exported function"
      },
      {
        "name": "Wire.offset2D",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "Wire",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      },
      {
        "name": "WrappingObj.unknown",
        "type": "class member",
        "nodeType": "Constructor",
        "reason": "public member"
      },
      {
        "name": "WrappingObj.wrapped",
        "type": "class member",
        "nodeType": "GetAccessor",
        "reason": "public member"
      },
      {
        "name": "WrappingObj.wrapped",
        "type": "class member",
        "nodeType": "SetAccessor",
        "reason": "public member"
      },
      {
        "name": "WrappingObj.delete",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "public member"
      },
      {
        "name": "WrappingObj",
        "type": "class",
        "nodeType": "ClassDeclaration",
        "reason": "exported class"
      }
    ],
    "removed": [
      {
        "name": "_1DShape._geomAdaptor",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "_3DShape._builderIter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d.pointer",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d.firstPoint",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d.pendingCurves",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._nextCorner",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._convertToUV",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._convertFromUV",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d.saveCurve",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._customCornerLastWithFirst",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._closeSketch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "BaseSketcher2d._closeWithMirror",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Blueprint._boundingBox",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Blueprint._orientation",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Blueprint._guessedOrientation",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Blueprints._boundingBox",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "CompoundBlueprint._boundingBox",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "CornerFinder.applyFilter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Curve._mapParameter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Curve2D._boundingBox",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private naming convention (underscore)"
      },
      {
        "name": "Curve2D.distanceFromPoint",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Curve2D.distanceFromCurve",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Drawing.innerShape",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Edge._geomAdaptor",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "EdgeFinder.applyFilter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Face._geomAdaptor",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceFinder.applyFilter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceSketcher.face",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceSketcher._bounds",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceSketcher._convertToUV",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceSketcher._convertFromUV",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "FaceSketcher._adaptSurface",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "private naming convention (underscore)"
      },
      {
        "name": "FaceSketcher.buildWire",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Finder.filters",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Finder.applyFilter",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Plane.oc",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "oc property excluded"
      },
      {
        "name": "Plane._origin",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Plane.localToGlobal",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Plane.globalToLocal",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      },
      {
        "name": "Plane._calcTransforms",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "private naming convention (underscore)"
      },
      {
        "name": "Shape._iterTopo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Shape._listTopo",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Shape._mesh",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketch._defaultOrigin",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private naming convention (underscore)"
      },
      {
        "name": "Sketch._defaultDirection",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private naming convention (underscore)"
      },
      {
        "name": "Sketch._baseFace",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher.plane",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher.pointer",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher.firstPoint",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher.pendingEdges",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher._mirrorWire",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher._updatePointer",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher._mirrorWireOnStartEnd",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher.buildWire",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Sketcher._closeSketch",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "Wire._geomAdaptor",
        "type": "class member",
        "nodeType": "MethodDeclaration",
        "reason": "protected member"
      },
      {
        "name": "WrappingObj.oc",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "oc property excluded"
      },
      {
        "name": "WrappingObj._wrapped",
        "type": "class member",
        "nodeType": "PropertyDeclaration",
        "reason": "private member"
      }
    ]
  }
}