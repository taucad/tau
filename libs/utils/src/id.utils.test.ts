import { describe, expect, it } from 'vitest';
import { idPrefix } from '@taucad/types/constants';
import { extractPrefix, generatePrefixedId, isValidPrefixedId, validatePrefixedId } from '@taucad/utils/id';

describe('id.utils', () => {
  describe('generatePrefixedId', () => {
    it('should generate an ID with the correct prefix', () => {
      const id = generatePrefixedId(idPrefix.message);
      expect(id).toMatch(/^msg_/);
    });

    it('should generate an ID with the expected format', () => {
      const id = generatePrefixedId(idPrefix.chat);
      expect(id).toMatch(/^chat_[\dA-Za-z]{21}$/);
    });

    it('should generate unique IDs on each call', () => {
      const ids = new Set<string>();

      for (let i = 0; i < 100; i++) {
        ids.add(generatePrefixedId(idPrefix.build));
      }

      expect(ids.size).toBe(100);
    });

    it('should work with all valid prefixes', () => {
      for (const prefix of Object.values(idPrefix)) {
        const id = generatePrefixedId(prefix);
        expect(id.startsWith(`${prefix}_`)).toBe(true);
      }
    });

    it('should generate IDs with exactly 21 character suffix', () => {
      const id = generatePrefixedId(idPrefix.user);
      const parts = id.split('_');
      expect(parts[1]).toHaveLength(21);
    });

    it('should only use alphanumeric characters in the suffix', () => {
      const id = generatePrefixedId(idPrefix.session);
      const suffix = id.split('_')[1];
      expect(suffix).toMatch(/^[\dA-Za-z]+$/);
    });
  });

  describe('validatePrefixedId', () => {
    it('should not throw for valid prefixed IDs', () => {
      expect(() => {
        validatePrefixedId('msg_abc123');
      }).not.toThrow();
      expect(() => {
        validatePrefixedId('chat_xyz789');
      }).not.toThrow();
      expect(() => {
        validatePrefixedId('bld_123abc');
      }).not.toThrow();
    });

    it('should throw for empty string', () => {
      expect(() => {
        validatePrefixedId('');
      }).toThrow('ID cannot be empty');
    });

    it('should throw for ID without underscore', () => {
      expect(() => {
        validatePrefixedId('msgabc123');
      }).toThrow('Invalid prefixed ID format: "msgabc123". Expected format: "prefix_id"');
    });

    it('should throw for ID with multiple underscores', () => {
      expect(() => {
        validatePrefixedId('msg_abc_123');
      }).toThrow('Invalid prefixed ID format: "msg_abc_123". Expected format: "prefix_id"');
    });

    it('should throw for ID with empty prefix', () => {
      expect(() => {
        validatePrefixedId('_abc123');
      }).toThrow('Invalid prefixed ID: "_abc123". Prefix cannot be empty');
    });

    it('should throw for ID with empty ID part', () => {
      expect(() => {
        validatePrefixedId('msg_');
      }).toThrow('Invalid prefixed ID: "msg_". ID part cannot be empty');
    });

    it('should throw for invalid prefix', () => {
      const validPrefixes = Object.values(idPrefix).join(', ');
      expect(() => {
        validatePrefixedId('invalid_abc123');
      }).toThrow(`Invalid prefix: "invalid". Valid prefixes are: ${validPrefixes}`);
    });

    it('should throw for prefix that looks similar but is invalid', () => {
      expect(() => {
        validatePrefixedId('message_abc123');
      }).toThrow(/Invalid prefix: "message"/);
      expect(() => {
        validatePrefixedId('MSG_abc123');
      }).toThrow(/Invalid prefix: "MSG"/);
    });

    it('should validate IDs generated by generatePrefixedId', () => {
      const id = generatePrefixedId(idPrefix.toolCall);
      expect(() => {
        validatePrefixedId(id);
      }).not.toThrow();
    });
  });

  describe('extractPrefix', () => {
    it('should extract the prefix from a valid ID', () => {
      expect(extractPrefix('msg_abc123')).toBe('msg');
      expect(extractPrefix('chat_xyz789')).toBe('chat');
      expect(extractPrefix('bld_123abc')).toBe('bld');
    });

    it('should extract prefix from IDs generated by generatePrefixedId', () => {
      const id = generatePrefixedId(idPrefix.source);
      expect(extractPrefix(id)).toBe(idPrefix.source);
    });

    it('should throw for invalid IDs', () => {
      expect(() => {
        extractPrefix('');
      }).toThrow('ID cannot be empty');
      expect(() => {
        extractPrefix('invalid');
      }).toThrow(/Invalid prefixed ID format/);
      expect(() => {
        extractPrefix('invalid_abc123');
      }).toThrow(/Invalid prefix/);
    });

    it('should return the correct prefix type for all valid prefixes', () => {
      for (const prefix of Object.values(idPrefix)) {
        const id = `${prefix}_testid123`;
        expect(extractPrefix(id)).toBe(prefix);
      }
    });
  });

  describe('isValidPrefixedId', () => {
    it('should return true for valid prefixed IDs', () => {
      expect(isValidPrefixedId('msg_abc123')).toBe(true);
      expect(isValidPrefixedId('chat_xyz789')).toBe(true);
      expect(isValidPrefixedId('bld_123abc')).toBe(true);
    });

    it('should return false for empty string', () => {
      expect(isValidPrefixedId('')).toBe(false);
    });

    it('should return false for ID without underscore', () => {
      expect(isValidPrefixedId('msgabc123')).toBe(false);
    });

    it('should return false for ID with multiple underscores', () => {
      expect(isValidPrefixedId('msg_abc_123')).toBe(false);
    });

    it('should return false for ID with empty prefix', () => {
      expect(isValidPrefixedId('_abc123')).toBe(false);
    });

    it('should return false for ID with empty ID part', () => {
      expect(isValidPrefixedId('msg_')).toBe(false);
    });

    it('should return false for invalid prefix', () => {
      expect(isValidPrefixedId('invalid_abc123')).toBe(false);
    });

    it('should return true for IDs generated by generatePrefixedId', () => {
      const id = generatePrefixedId(idPrefix.run);
      expect(isValidPrefixedId(id)).toBe(true);
    });

    it('should work as a type guard', () => {
      const maybeId = 'msg_abc123';
      if (isValidPrefixedId(maybeId)) {
        // TypeScript should narrow the type here
        const narrowedId: `${(typeof idPrefix)[keyof typeof idPrefix]}_${string}` = maybeId;
        expect(narrowedId).toBe(maybeId);
      }
    });

    it('should validate all prefix types', () => {
      for (const prefix of Object.values(idPrefix)) {
        expect(isValidPrefixedId(`${prefix}_validid123`)).toBe(true);
      }
    });
  });

  describe('integration tests', () => {
    it('should round-trip through generate, validate, and extract', () => {
      for (const prefix of Object.values(idPrefix)) {
        const id = generatePrefixedId(prefix);

        // Should be valid
        expect(isValidPrefixedId(id)).toBe(true);

        // Should not throw
        expect(() => {
          validatePrefixedId(id);
        }).not.toThrow();

        // Should extract the same prefix
        expect(extractPrefix(id)).toBe(prefix);
      }
    });

    it('should generate IDs that pass strict validation', () => {
      const iterations = 50;
      for (let i = 0; i < iterations; i++) {
        const prefix = Object.values(idPrefix)[i % Object.values(idPrefix).length]!;
        const id = generatePrefixedId(prefix);

        expect(isValidPrefixedId(id)).toBe(true);
        expect(extractPrefix(id)).toBe(prefix);
      }
    });
  });
});
